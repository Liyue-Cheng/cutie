# Cutie XML工具调用功能详细设计方案

## 目录
1. [总体架构](#总体架构)
2. [数据流设计](#数据流设计)
3. [核心模块详细设计](#核心模块详细设计)
4. [与现有系统的集成](#与现有系统的集成)
5. [用户交互流程](#用户交互流程)
6. [错误处理策略](#错误处理策略)
7. [性能优化方案](#性能优化方案)
8. [测试策略](#测试策略)
9. [实施路线图](#实施路线图)

---

## 1. 总体架构

### 1.1 架构层次

```
┌─────────────────────────────────────────────────────────────┐
│                        用户界面层                              │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐      │
│  │  聊天面板    │  │  工具批准框   │  │  结果展示    │      │
│  └──────────────┘  └──────────────┘  └──────────────┘      │
└─────────────────────────────────────────────────────────────┘
                            ↕
┌─────────────────────────────────────────────────────────────┐
│                      状态管理层 (Pinia)                        │
│  ┌──────────────────────────────────────────────────────┐   │
│  │  useAiStore (已存在)                                  │   │
│  │  - messages                                          │   │
│  │  - isLoading                                         │   │
│  │  - sendMessage()                                     │   │
│  └──────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────┘
                            ↕
┌─────────────────────────────────────────────────────────────┐
│                    CPU Pipeline 调度层                         │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐      │
│  │ ai.stream    │  │ ai.tool_exec │  │ ai.update    │      │
│  └──────────────┘  └──────────────┘  └──────────────┘      │
└─────────────────────────────────────────────────────────────┘
                            ↕
┌─────────────────────────────────────────────────────────────┐
│                      AI服务层 (核心)                           │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐      │
│  │ XML解析器    │  │ 流处理器     │  │ 工具执行器    │      │
│  └──────────────┘  └──────────────┘  └──────────────┘      │
│  ┌──────────────┐  ┌──────────────┐                        │
│  │ 提示词生成   │  │ AI客户端     │                        │
│  └──────────────┘  └──────────────┘                        │
└─────────────────────────────────────────────────────────────┘
                            ↕
┌─────────────────────────────────────────────────────────────┐
│                    工具实现层 (业务逻辑)                        │
│  ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐          │
│  │创建任务 │ │读取任务 │ │更新任务 │ │创建日程 │ ...      │
│  └─────────┘ └─────────┘ └─────────┘ └─────────┘          │
└─────────────────────────────────────────────────────────────┘
                            ↕
┌─────────────────────────────────────────────────────────────┐
│                      后端API层 (Tauri/Rust)                    │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐      │
│  │ SSE流式端点  │  │ 任务API      │  │ 日程API      │      │
│  └──────────────┘  └──────────────┘  └──────────────┘      │
└─────────────────────────────────────────────────────────────┘
```

### 1.2 架构原则

#### 1.2.1 分层原则
- **UI层**：只负责展示和用户交互，不包含业务逻辑
- **状态层**：管理应用状态，协调各层通信
- **调度层**：CPU Pipeline负责异步任务调度和并发控制
- **服务层**：核心AI逻辑，包括解析、执行、流处理
- **工具层**：具体工具实现，调用现有API
- **后端层**：Rust服务，处理HTTP和SSE

#### 1.2.2 解耦原则
- **XML解析器**独立于工具实现
- **工具执行器**不依赖具体工具
- **流处理器**不关心工具调用细节
- **UI组件**通过Store与服务层通信

#### 1.2.3 扩展原则
- 新增工具：只需添加工具实现和提示词描述
- 新增模型：只需调整API客户端
- 新增UI：只需订阅Store状态

---

## 2. 数据流设计

### 2.1 完整对话流程

```
用户输入消息
    ↓
Store.sendMessage()
    ↓
构建系统提示词 (包含XML工具格式说明)
    ↓
发送HTTP请求到后端 /api/ai/chat (SSE)
    ↓
后端调用OpenAI兼容SDK
    ↓
【流式响应开始】
    ↓
事件流: text chunk → text chunk → text chunk → ...
    ↓
前端流处理器接收每个chunk
    ↓
XML解析器逐字符解析
    ↓
【检测到工具调用】
    ↓
解析出完整的 <tool_use>...</tool_use>
    ↓
工具执行器路由到具体工具
    ↓
工具调用现有API (例如 POST /api/tasks)
    ↓
获取工具执行结果
    ↓
【选项A: 单轮对话】将结果展示给用户，结束
【选项B: 多轮对话】将结果反馈给AI，继续对话
    ↓
AI根据工具结果生成新的回复
    ↓
【流式响应继续/结束】
```

### 2.2 数据结构转换链

```
用户输入 (string)
    ↓
ChatMessage { role: "user", text: string }
    ↓
AiChatRequest { messages: ChatMessage[], system: string }
    ↓
HTTP SSE Stream
    ↓
SSE Event { data: { type: "text", content: string } }
    ↓
XML Parser Input (string chunks)
    ↓
ToolUse { type: "tool_use", name: string, params: Record<string, string> }
    ↓
具体工具参数 { task_id: string, title: string, ... }
    ↓
API Request Body
    ↓
API Response
    ↓
ToolResult { success: boolean, message: string, data?: any }
    ↓
AssistantMessage { role: "assistant", text: string }
    ↓
Store更新UI
```

### 2.3 状态变化时序

```
时刻 T0: 初始状态
  isLoading = false
  messages = []

时刻 T1: 用户发送消息
  isLoading = true
  messages = [{ role: "user", text: "创建任务" }]

时刻 T2: 流式响应开始
  isLoading = true
  messages = [..., { role: "assistant", text: "" }]

时刻 T3: 接收文本chunk
  messages = [..., { role: "assistant", text: "好的，我来帮你创建" }]

时刻 T4: 检测到工具调用
  【内部状态】currentTool = { name: "create_task", partial: true }
  【UI显示】正在解析工具...

时刻 T5: 工具解析完成
  【内部状态】currentTool = { name: "create_task", params: {...}, partial: false }
  【UI显示】正在执行工具: create_task

时刻 T6: 工具执行完成
  messages = [..., { role: "assistant", text: "...任务已创建" }]
  【UI显示】工具执行成功

时刻 T7: 流式响应结束
  isLoading = false
  messages = [..., { role: "assistant", text: "完整回复" }]
```

---

## 3. 核心模块详细设计

### 3.1 XML解析器模块

#### 3.1.1 职责
- 接收流式文本chunk
- 逐字符解析XML工具调用
- 维护解析状态机
- 输出完整的工具调用对象

#### 3.1.2 状态机设计

```
状态0: 初始状态
  ↓ 检测到 "<tool_use>"
状态1: 工具调用开始
  ↓ 检测到 '<invoke name="xxx">'
状态2: 工具名称已解析
  ↓ 检测到 '<parameter name="yyy">'
状态3: 参数名称已解析
  ↓ 接收参数值内容
状态4: 参数值累加中
  ↓ 检测到 '</parameter>'
状态5: 参数解析完成
  ↓ 重复状态3-5解析其他参数
  ↓ 检测到 '</invoke>'
状态6: 工具调用完成
  ↓ 输出 ToolUse 对象，返回状态0
```

#### 3.1.3 关键数据结构

**内部状态**:
- `accumulator`: 字符累加器（完整字符串）
- `currentToolUse`: 当前正在解析的工具对象（可能不完整）
- `currentParamName`: 当前正在解析的参数名
- `currentParamValueStartIndex`: 参数值在accumulator中的起始位置

**输出对象**:
- `ToolUse`: 完整的工具调用对象
  - `type`: "tool_use"
  - `name`: 工具名称（字符串）
  - `params`: 参数对象（所有值都是字符串）
  - `partial`: 是否为部分解析（流式中间状态）

#### 3.1.4 边界情况处理

**场景1：跨chunk的XML标签**
```
chunk1: "...创建任务<tool_"
chunk2: "use><invoke name=\"cre"
chunk3: "ate_task\">..."
```
- **处理**: accumulator累加所有chunk，状态机逐字符匹配

**场景2：参数值包含特殊字符**
```
<parameter name="title">任务<包含>特殊字符</parameter>
```
- **处理**: 贪婪匹配到第一个`</parameter>`，不解析内部标签

**场景3：XML格式错误**
```
<tool_use><invoke name="test">  <!-- 缺少 </invoke> -->
```
- **处理**: 设置超时，超过一定时间未完成则标记为错误

**场景4：累加器溢出**
```
accumulator.length > 1MB
```
- **处理**: 抛出异常，防止内存泄漏

#### 3.1.5 性能优化

**优化1：避免全量字符串操作**
- 使用索引标记位置，减少字符串切片

**优化2：正则表达式缓存**
- 预编译常用正则，避免重复编译

**优化3：早期中止**
- 检测到完整工具后立即输出，不等待整个消息结束

---

### 3.2 流处理器模块

#### 3.2.1 职责
- 管理SSE事件流连接
- 解析SSE事件格式
- 调用XML解析器处理文本chunk
- 分离纯文本和工具调用内容
- 触发工具执行回调

#### 3.2.2 SSE事件格式

**后端发送的事件格式**:
```
event: message
data: {"type":"text","content":"你好"}

event: message
data: {"type":"text","content":"<tool_use>..."}

event: done
data: {"type":"done"}

event: error
data: {"type":"error","message":"..."}
```

#### 3.2.3 流处理逻辑

**处理流程**:
1. 建立EventSource连接
2. 监听`message`事件
3. 解析JSON数据
4. 判断事件类型:
   - `text`: 传递给XML解析器
   - `done`: 关闭流，标记完成
   - `error`: 处理错误

**文本清洗**:
- 从AI响应中移除XML工具调用部分
- 只保留纯文本内容展示给用户
- 正则表达式: `/<tool_use>[\s\S]*?<\/tool_use>/g`

**工具调用检测**:
- XML解析器返回完整ToolUse对象时
- 暂停文本输出
- 调用工具执行回调
- 等待工具执行完成
- 继续文本输出

#### 3.2.4 并发控制

**问题**: 流式过程中可能检测到多个工具调用

**方案**: 串行执行
1. 检测到第一个工具 → 执行 → 等待完成
2. 检测到第二个工具 → 执行 → 等待完成
3. ...

**原因**: 任务管理工具有依赖关系（例如先创建后更新）

#### 3.2.5 错误恢复

**场景1：网络中断**
- 检测连接断开
- 设置错误状态
- 允许用户重试

**场景2：解析失败**
- 捕获XML解析异常
- 记录错误日志
- 显示友好错误信息
- 跳过当前工具，继续处理

**场景3：工具执行失败**
- 捕获工具异常
- 记录失败信息
- 继续流式处理（不中断整个对话）

---

### 3.3 工具执行器模块

#### 3.3.1 职责
- 接收ToolUse对象
- 参数类型转换（string → typed）
- 路由到具体工具实现
- 统一错误处理
- 返回执行结果

#### 3.3.2 工具路由表

**注册机制**:
```
工具名称 → 工具函数
"create_task" → createTaskTool()
"read_tasks" → readTasksTool()
"update_task" → updateTaskTool()
"create_schedule" → createScheduleTool()
"delete_task" → deleteTaskTool()
```

**动态扩展**:
- 新增工具只需注册到路由表
- 无需修改执行器核心逻辑

#### 3.3.3 参数转换策略

**问题**: XML解析出来的所有参数都是string类型

**转换规则**:
1. **布尔值**: "true" → true, "false" → false
2. **数字**: 正则匹配 `/^\d+$/` → parseInt()
3. **日期**: 保持字符串（后端验证格式）
4. **UUID**: 保持字符串
5. **可选参数**: undefined 保持 undefined

**转换函数设计**:
- 输入: `Record<string, string>`
- 输出: `Record<string, any>`
- 策略: 根据参数名或值模式推断类型

**示例转换**:
```
输入:
{
  "title": "完成报告",
  "completed": "true",
  "priority": "3"
}

输出:
{
  title: "完成报告",
  completed: true,
  priority: 3
}
```

#### 3.3.4 工具执行流程

```
接收 ToolUse
    ↓
验证工具名称（是否在路由表中）
    ↓
参数类型转换
    ↓
参数验证（必填、格式等）
    ↓
调用具体工具函数
    ↓
【异步等待】
    ↓
获取执行结果
    ↓
统一格式化为 ToolResult
    ↓
返回结果
```

#### 3.3.5 错误分类处理

**类型1：工具不存在**
- 错误码: TOOL_NOT_FOUND
- 处理: 返回错误结果，建议可用工具列表

**类型2：参数缺失**
- 错误码: MISSING_PARAMETER
- 处理: 返回错误结果，说明缺少哪个参数

**类型3：参数格式错误**
- 错误码: INVALID_PARAMETER
- 处理: 返回错误结果，说明期望的格式

**类型4：工具执行失败**
- 错误码: EXECUTION_FAILED
- 处理: 返回错误结果，包含具体错误信息

**类型5：后端API错误**
- 错误码: API_ERROR
- 处理: 返回错误结果，包含HTTP状态码和响应

---

### 3.4 工具实现层

#### 3.4.1 工具标准接口

**输入**:
- 类型化参数对象（已转换）
- 可选的执行上下文（用户信息、权限等）

**输出**:
- ToolResult 对象
  - `success`: 是否成功
  - `message`: 用户友好的描述信息
  - `data`: 返回的数据（可选）

**异常**:
- 抛出Error对象，由执行器捕获

#### 3.4.2 工具实现清单

**1. create_task - 创建任务**

输入参数:
- `title` (必填): 任务标题
- `area_id` (可选): 所属区域ID
- `scheduled_date` (可选): 计划日期

执行逻辑:
1. 验证参数
2. 调用 `POST /api/tasks`
3. 解析响应
4. 返回结果

成功返回:
```
{
  success: true,
  message: "任务「完成报告」已创建",
  data: { id: "uuid", title: "完成报告", ... }
}
```

**2. read_tasks - 读取任务列表**

输入参数:
- `view_context` (必填): 视图上下文
  - 格式: `daily::2024-01-01` | `staging` | `area::uuid`

执行逻辑:
1. 解析view_context
2. 调用 `GET /api/views/{context}/tasks`
3. 格式化任务列表
4. 返回结果

成功返回:
```
{
  success: true,
  message: "找到 5 个任务",
  data: { tasks: [...] }
}
```

**3. update_task - 更新任务**

输入参数:
- `task_id` (必填): 任务ID
- `title` (可选): 新标题
- `completed` (可选): 是否完成

执行逻辑:
1. 验证task_id存在
2. 构建PATCH请求体（只包含提供的字段）
3. 调用 `PATCH /api/tasks/{id}`
4. 返回结果

成功返回:
```
{
  success: true,
  message: "任务已更新",
  data: { id: "uuid", ... }
}
```

**4. create_schedule - 创建日程**

输入参数:
- `task_id` (必填): 任务ID
- `scheduled_date` (必填): 日期

执行逻辑:
1. 验证task_id存在
2. 验证日期格式
3. 调用 `POST /api/tasks/{id}/schedules`
4. 返回结果

成功返回:
```
{
  success: true,
  message: "已为任务创建日程：2024-01-15",
  data: { schedule_id: "uuid", ... }
}
```

**5. delete_task - 删除任务**

输入参数:
- `task_id` (必填): 任务ID

执行逻辑:
1. 验证task_id存在
2. 调用 `DELETE /api/tasks/{id}`
3. 返回结果

成功返回:
```
{
  success: true,
  message: "任务已删除",
  data: null
}
```

#### 3.4.3 工具通用逻辑

**HTTP客户端复用**:
- 使用Cutie现有的 `apiBaseUrl.value`
- 统一的错误处理
- 自动添加请求头

**响应格式统一**:
- 所有后端API返回 `ApiResponse<T>` 格式
- 工具层需要提取 `.data` 字段

**日志记录**:
- 工具调用开始: `logger.debug('Tool: create_task', params)`
- 工具调用成功: `logger.info('Tool succeeded', result)`
- 工具调用失败: `logger.error('Tool failed', error)`

---

### 3.5 提示词生成器模块

#### 3.5.1 职责
- 生成系统提示词
- 包含XML格式说明
- 包含所有工具的详细描述
- 包含使用规则和示例

#### 3.5.2 提示词结构

**第一部分：角色定义**
```
你是一个任务管理助手，帮助用户管理任务和日程。
```

**第二部分：XML格式说明**
```
当需要执行操作时，请使用以下XML格式：
<tool_use>
<invoke name="工具名称">
<parameter name="参数名">参数值</parameter>
</invoke>
</tool_use>
```

**第三部分：工具描述**
- 每个工具一个小节
- 包含：工具名、描述、参数列表、示例

**第四部分：使用规则**
```
重要规则：
1. 每次只调用一个工具
2. 所有参数都是字符串
3. 布尔值用 "true"/"false"
4. 严格按照XML格式
```

**第五部分：目标说明**
```
你的目标：高效帮助用户管理任务，提供清晰反馈。
```

#### 3.5.3 工具描述模板

**标准格式**:
```
### 工具名称
描述：简短说明

参数：
- 参数1 (必填/可选): 描述
- 参数2 (必填/可选): 描述

示例：
<tool_use>
<invoke name="工具名称">
<parameter name="参数1">值1</parameter>
<parameter name="参数2">值2</parameter>
</invoke>
</tool_use>
```

#### 3.5.4 动态生成策略

**根据上下文调整**:
- 如果用户在某个日期视图，提示词中包含当前日期
- 如果用户在某个区域，提示词中包含当前区域ID
- 可用工具列表根据权限动态生成

**示例变量替换**:
```
当前日期: {today}
当前区域: {current_area_id}
用户名称: {user_name}
```

---

### 3.6 AI客户端模块

#### 3.6.1 职责
- 管理与后端AI端点的通信
- 发送聊天请求
- 建立SSE连接
- 处理网络错误和重试

#### 3.6.2 API接口设计

**请求端点**: `POST /api/ai/chat/stream`

**请求格式**:
```
{
  "messages": [
    { "role": "user", "text": "创建任务" },
    { "role": "assistant", "text": "好的" }
  ],
  "system": "系统提示词（包含XML工具说明）",
  "max_tokens": 2000,
  "stream": true
}
```

**响应格式**: SSE事件流
```
event: message
data: {"type":"text","content":"文本chunk"}

event: message
data: {"type":"text","content":"<tool_use>..."}

event: done
data: {"type":"done"}
```

#### 3.6.3 连接管理

**连接建立**:
1. 使用 `fetch` API 发起请求
2. 设置 `Accept: text/event-stream`
3. 获取响应的 `ReadableStream`
4. 创建 `TextDecoder` 解析流

**连接保活**:
- 设置心跳检测（每30秒）
- 超时未收到数据则重连

**连接关闭**:
- 收到 `done` 事件后主动关闭
- 用户取消请求时中止连接
- 错误发生时清理资源

#### 3.6.4 错误处理

**网络错误**:
- 连接失败: 显示"无法连接到服务器"
- 超时: 显示"请求超时，请重试"
- 中断: 显示"连接中断"

**业务错误**:
- 401: "未授权，请登录"
- 429: "请求过于频繁，请稍后重试"
- 500: "服务器错误"

**重试策略**:
- 自动重试: 网络瞬断（最多3次）
- 手动重试: 其他错误（提供重试按钮）
- 指数退避: 1s, 2s, 4s

---

## 4. 与现有系统的集成

### 4.1 与Pinia Store的集成

#### 4.1.1 现有Store扩展

**当前结构**:
```
useAiStore:
  - messages: Ref<ChatMessage[]>
  - isLoading: Ref<boolean>
  - error: Ref<string | null>
  - sendMessage(message): Promise<void>
```

**新增状态**:
```
useAiStore:
  【新增】
  - currentTool: Ref<ToolUse | null>  // 当前正在执行的工具
  - toolHistory: Ref<ToolResult[]>    // 工具执行历史
  - streamingText: Ref<string>        // 流式文本累加
  - isToolExecuting: Ref<boolean>     // 工具执行状态
```

**新增方法**:
```
useAiStore:
  【新增】
  - sendMessageWithTools(message): Promise<void>  // 支持工具调用的发送
  - executeToolManually(tool): Promise<void>      // 手动执行工具
  - cancelStream(): void                          // 取消流式请求
  - retryLastMessage(): Promise<void>             // 重试上次请求
```

#### 4.1.2 状态更新策略

**原则**: 所有状态变更通过Store的mutation方法

**流程**:
1. UI触发 `sendMessage()`
2. Store设置 `isLoading = true`
3. 流处理器回调 → Store更新 `streamingText`
4. 工具检测 → Store更新 `currentTool`
5. 工具执行 → Store更新 `toolHistory`
6. 完成 → Store设置 `isLoading = false`

**响应式更新**:
- Vue组件订阅Store状态
- 状态变化自动触发UI重渲染
- 无需手动管理DOM

### 4.2 与CPU Pipeline的集成

#### 4.2.1 新增指令集

**AI相关指令**:
```
'ai.stream.start': 开始流式对话
  payload: { message: string }

'ai.stream.chunk': 接收流式chunk
  payload: { text: string }

'ai.tool.detected': 检测到工具调用
  payload: { tool: ToolUse }

'ai.tool.execute': 执行工具
  payload: { tool: ToolUse }

'ai.tool.complete': 工具执行完成
  payload: { result: ToolResult }

'ai.stream.end': 流式对话结束
  payload: { success: boolean }
```

#### 4.2.2 指令执行流程

```
用户点击发送
  ↓
UI dispatch('ai.stream.start', { message })
  ↓
Pipeline调度到IF阶段
  ↓
SCH阶段：优先级调度
  ↓
EX阶段：执行流式请求
  ↓
【流式事件】
  ↓
每个chunk dispatch('ai.stream.chunk', { text })
  ↓
检测到工具 dispatch('ai.tool.detected', { tool })
  ↓
SCH阶段：调度工具执行指令
  ↓
EX阶段：执行工具 dispatch('ai.tool.execute', { tool })
  ↓
工具完成 dispatch('ai.tool.complete', { result })
  ↓
流式结束 dispatch('ai.stream.end', { success: true })
  ↓
WB阶段：更新Store状态
```

#### 4.2.3 并发控制

**问题**: 多个AI请求或工具执行冲突

**方案**: Pipeline的资源冲突检测
- AI流式请求：独占资源 `ai.stream`
- 工具执行：共享资源 `tools.*`（串行）
- 其他CPU指令：正常调度

**示例**:
```
指令1: ai.stream.start (占用 ai.stream)
指令2: task.update (可并发)
指令3: ai.stream.start (等待指令1完成)
```

### 4.3 与后端API的集成

#### 4.3.1 新增后端端点

**Rust后端需要新增**:

**1. 流式聊天端点**
```
POST /api/ai/chat/stream
  Request: { messages, system, max_tokens, stream: true }
  Response: SSE事件流
```

**2. 非流式聊天端点（可选）**
```
POST /api/ai/chat
  Request: { messages, system, max_tokens }
  Response: { reply, usage, model, response_time_ms }
```

#### 4.3.2 后端实现要点

**OpenAI兼容SDK调用**:
- 使用Rust的`reqwest`库
- 调用用户配置的OpenAI兼容端点
- 传递完整的messages历史
- 包含system提示词（含XML工具说明）

**流式响应转发**:
- 后端接收模型的流式响应
- 包装成SSE格式
- 转发给前端
- 处理异常和超时

**配置管理**:
- API Base URL（用户配置）
- API Key（用户配置）
- 模型名称（用户选择）
- 超时时间（默认60秒）

#### 4.3.3 错误边界

**后端错误处理**:
- 捕获SDK异常
- 发送SSE错误事件
- 记录错误日志
- 返回友好错误信息

**前端错误处理**:
- 接收错误事件
- 更新Store错误状态
- 显示错误提示
- 提供重试选项

### 4.4 与现有UI组件的集成

#### 4.4.1 复用现有组件

**可复用**:
- `CuteButton` - 发送按钮、工具批准按钮
- `CuteIcon` - 状态图标、工具图标
- `CutePane` - 聊天面板布局
- `CuteCard` - 消息卡片、工具卡片

**需要新建**:
- `AiChatPanel.vue` - 主聊天面板
- `AiMessageBubble.vue` - 消息气泡
- `AiToolCallDisplay.vue` - 工具调用展示
- `AiToolApprovalDialog.vue` - 工具批准对话框（可选）

#### 4.4.2 UI状态联动

**加载状态**:
- `isLoading = true` → 显示输入框禁用 + Loading动画
- `isToolExecuting = true` → 显示"正在执行工具..."

**错误状态**:
- `error !== null` → 显示错误提示条
- 提供"重试"和"关闭"按钮

**工具状态**:
- `currentTool !== null && partial = true` → 显示"正在解析工具..."
- `currentTool !== null && partial = false` → 显示"正在执行: {tool.name}"

---

## 5. 用户交互流程

### 5.1 基础对话流程

```
【用户视角】

1. 用户打开AI聊天面板
   ↓
2. 输入消息："创建一个任务，标题是完成项目报告"
   ↓
3. 点击发送按钮
   ↓
4. 看到用户消息显示在聊天区域
   ↓
5. 看到AI回复开始逐字显示：
   "好的，我来帮你创建任务..."
   ↓
6. 【看到工具调用】
   显示一个特殊的卡片：
   "🔧 正在执行工具: create_task
    参数: title = 完成项目报告"
   ↓
7. 工具执行完成，卡片更新：
   "✅ 工具执行成功
    任务「完成项目报告」已创建"
   ↓
8. AI继续回复：
   "任务已经为你创建好了，你可以在今日视图中看到它。"
   ↓
9. 对话结束
```

### 5.2 多工具调用流程

```
【用户视角】

1. 用户："帮我创建3个任务"
   ↓
2. AI开始回复并执行工具：
   ↓
3. 【工具1】create_task (任务1)
   显示：✅ 任务「任务1」已创建
   ↓
4. 【工具2】create_task (任务2)
   显示：✅ 任务「任务2」已创建
   ↓
5. 【工具3】create_task (任务3)
   显示：✅ 任务「任务3」已创建
   ↓
6. AI最终回复：
   "已经为你创建了3个任务。"
```

### 5.3 错误处理流程

```
【用户视角】

场景1：网络错误
1. 用户发送消息
   ↓
2. 显示加载中...
   ↓
3. 网络超时
   ↓
4. 显示错误提示：
   "⚠️ 请求超时，请检查网络连接"
   [重试] [取消]
   ↓
5. 用户点击重试
   ↓
6. 重新发送请求

场景2：工具执行失败
1. AI检测到工具调用
   ↓
2. 执行create_task
   ↓
3. 后端返回错误（例如：必填字段缺失）
   ↓
4. 显示：
   "❌ 工具执行失败
    错误: 任务标题不能为空"
   ↓
5. AI继续回复：
   "抱歉，创建任务失败了。请提供任务标题。"
```

### 5.4 用户批准流程（可选功能）

```
【用户视角】

1. 用户："删除所有已完成的任务"
   ↓
2. AI检测到工具调用：delete_task
   ↓
3. 【弹出批准对话框】
   "AI想要执行以下操作：
    🗑️ 删除任务

    参数：
    - task_id: xxx-xxx-xxx
    - title: 已完成的任务

    是否允许？
    [允许] [拒绝]"
   ↓
4a. 用户点击"允许"
    → 执行工具
    → 显示成功结果

4b. 用户点击"拒绝"
    → 取消工具执行
    → AI收到拒绝反馈
    → AI回复："好的，我不会删除任务了。"
```

### 5.5 流式体验优化

**实时反馈**:
- 文本逐字显示（打字机效果）
- 工具调用实时显示进度
- 加载动画平滑过渡

**取消功能**:
- 提供"停止生成"按钮
- 点击后立即中止流式请求
- 保留已生成的内容

**重试功能**:
- 错误后提供重试按钮
- 保留原始输入
- 一键重新发送

---

## 6. 错误处理策略

### 6.1 错误分类

#### 6.1.1 网络层错误

**错误类型**:
- 连接失败
- 超时
- 网络中断
- DNS解析失败

**处理策略**:
- 显示网络错误提示
- 自动重试（最多3次）
- 提供手动重试按钮
- 建议检查网络设置

#### 6.1.2 解析层错误

**错误类型**:
- XML格式错误
- 未闭合标签
- 参数缺失
- 累加器溢出

**处理策略**:
- 记录详细错误日志
- 跳过当前工具调用
- 继续处理后续内容
- 不中断整个对话

#### 6.1.3 执行层错误

**错误类型**:
- 工具不存在
- 参数验证失败
- API调用失败
- 业务逻辑错误

**处理策略**:
- 返回详细错误信息
- 反馈给AI模型
- 让AI根据错误调整策略
- 记录错误到工具历史

#### 6.1.4 业务层错误

**错误类型**:
- 任务不存在
- 权限不足
- 数据冲突
- 验证失败

**处理策略**:
- 返回友好错误信息
- 提供修正建议
- 允许用户修改参数
- 记录业务日志

### 6.2 错误恢复机制

#### 6.2.1 自动恢复

**场景**:
- 瞬时网络故障
- 服务器临时不可用
- 轻微的解析错误

**策略**:
- 指数退避重试
- 最大重试次数限制
- 透明恢复（用户无感知）

#### 6.2.2 手动恢复

**场景**:
- 持续网络故障
- 配置错误
- 严重的业务错误

**策略**:
- 显示错误详情
- 提供重试按钮
- 提供配置检查入口
- 提供反馈通道

#### 6.2.3 降级策略

**场景**:
- 流式请求失败
- 工具调用不可用

**策略**:
- 降级到非流式模式
- 禁用工具调用，纯文本对话
- 显示降级提示
- 保持基础功能可用

### 6.3 错误日志

#### 6.3.1 日志分级

**DEBUG**: 调试信息
- XML解析过程
- 工具参数转换
- 流式chunk内容

**INFO**: 正常操作
- 工具调用开始
- 工具执行成功
- 对话完成

**WARN**: 警告信息
- 解析警告
- 非致命错误
- 性能问题

**ERROR**: 错误信息
- 网络错误
- 工具执行失败
- 严重异常

#### 6.3.2 日志内容

**必须包含**:
- 时间戳
- 错误类型
- 错误消息
- 堆栈跟踪
- 上下文信息（工具名、参数等）

**敏感信息处理**:
- 用户输入脱敏
- API Key隐藏
- 个人信息移除

---

## 7. 性能优化方案

### 7.1 解析性能优化

**优化点1：减少字符串操作**
- 使用索引而不是字符串切片
- 缓存常用正则表达式
- 避免不必要的字符串拼接

**优化点2：早期返回**
- 检测到完整工具立即返回
- 不等待整个消息处理完成
- 减少不必要的解析

**优化点3：内存控制**
- 设置累加器大小限制
- 及时清理已处理内容
- 避免内存泄漏

### 7.2 网络性能优化

**优化点1：连接复用**
- 保持HTTP连接活跃
- 减少连接建立开销
- 使用keep-alive

**优化点2：数据压缩**
- 启用gzip压缩
- 减少传输数据量
- 加快响应速度

**优化点3：并发控制**
- 限制同时请求数
- 避免资源竞争
- 队列管理

### 7.3 UI性能优化

**优化点1：虚拟滚动**
- 长对话列表使用虚拟滚动
- 只渲染可见消息
- 减少DOM节点数

**优化点2：防抖节流**
- 输入框防抖（300ms）
- 滚动事件节流
- 减少不必要的渲染

**优化点3：懒加载**
- 历史消息按需加载
- 图片懒加载
- 减少初始加载时间

### 7.4 缓存策略

**缓存内容**:
- 提示词模板
- 工具描述
- 最近的对话历史

**缓存失效**:
- 配置变更时清除
- 工具列表更新时清除
- 用户主动清除

---

## 8. 测试策略

### 8.1 单元测试

**测试目标**:
- XML解析器
- 参数转换函数
- 工具路由器
- 错误处理逻辑

**测试用例**:
- 正常情况：完整XML、各种参数类型
- 边界情况：空字符串、超长字符串
- 异常情况：格式错误、缺失标签
- 并发情况：多个工具、中断恢复

### 8.2 集成测试

**测试目标**:
- 流处理 + XML解析
- 工具执行 + API调用
- Store更新 + UI渲染
- 错误处理 + 恢复

**测试用例**:
- 端到端流程：用户输入 → 工具执行 → 结果展示
- 多工具场景：连续工具调用
- 错误场景：网络失败、工具失败
- 并发场景：多个请求同时进行

### 8.3 端到端测试

**测试目标**:
- 完整用户场景
- 真实网络环境
- 实际后端交互

**测试用例**:
- 场景1：创建任务对话
- 场景2：查询任务对话
- 场景3：更新任务对话
- 场景4：复杂多轮对话
- 场景5：错误恢复对话

### 8.4 性能测试

**测试目标**:
- 解析性能
- 网络延迟
- UI响应速度
- 内存使用

**测试指标**:
- 解析速度：< 10ms/工具
- 响应延迟：< 100ms
- UI渲染：60fps
- 内存占用：< 100MB

---

## 9. 实施路线图

### 9.1 Phase 1: 基础架构 (3天)

**Day 1: 类型定义和XML解析器**
- 目标：完成核心解析逻辑
- 交付物：
  - 类型定义文件
  - XML解析器实现
  - 单元测试（覆盖率 > 80%）

**Day 2: 提示词系统**
- 目标：生成完整的系统提示词
- 交付物：
  - 提示词生成器
  - 5个工具的完整描述
  - 使用规则和示例

**Day 3: Store和Pipeline集成**
- 目标：扩展现有Store，定义Pipeline指令
- 交付物：
  - 扩展的useAiStore
  - AI相关指令集
  - 状态管理测试

### 9.2 Phase 2: 工具实现 (3天)

**Day 4: 工具执行器框架**
- 目标：完成工具路由和参数转换
- 交付物：
  - 工具执行器
  - 参数转换函数
  - 错误处理逻辑

**Day 5: 基础工具实现 (1/2)**
- 目标：实现create_task、read_tasks
- 交付物：
  - createTaskTool完整实现
  - readTasksTool完整实现
  - 工具集成测试

**Day 6: 基础工具实现 (2/2)**
- 目标：实现update_task、create_schedule、delete_task
- 交付物：
  - 其余3个工具实现
  - 完整工具测试套件
  - 工具文档

### 9.3 Phase 3: 流处理和通信 (3天)

**Day 7: 流处理器**
- 目标：实现SSE流式处理
- 交付物：
  - 流处理器实现
  - 与XML解析器集成
  - 工具触发逻辑

**Day 8: AI客户端**
- 目标：实现与后端通信
- 交付物：
  - AI客户端实现
  - 网络错误处理
  - 重试机制

**Day 9: Pipeline调度集成**
- 目标：完整的指令调度流程
- 交付物：
  - 所有AI指令实现
  - 并发控制
  - 端到端测试

### 9.4 Phase 4: 后端实现 (2天)

**Day 10: Rust后端SSE端点**
- 目标：实现流式聊天端点
- 交付物：
  - POST /api/ai/chat/stream
  - OpenAI SDK集成
  - 流式转发逻辑

**Day 11: 后端错误处理和测试**
- 目标：完善后端功能
- 交付物：
  - 错误处理
  - 日志记录
  - 后端测试

### 9.5 Phase 5: UI实现 (2天)

**Day 12: 聊天UI组件**
- 目标：实现基础聊天界面
- 交付物：
  - AiChatPanel.vue
  - AiMessageBubble.vue
  - 消息列表

**Day 13: 工具调用UI**
- 目标：工具调用可视化
- 交付物：
  - AiToolCallDisplay.vue
  - 加载状态显示
  - 错误提示

### 9.6 Phase 6: 优化和完善 (2天)

**Day 14: 性能优化**
- 目标：优化性能和体验
- 交付物：
  - 解析性能优化
  - UI流畅度优化
  - 内存优化

**Day 15: 测试和发布**
- 目标：完整测试和上线
- 交付物：
  - 完整测试报告
  - 用户文档
  - 发布版本

---

## 10. 技术决策总结

### 10.1 核心决策

| 决策点 | 选择 | 理由 |
|--------|------|------|
| **工具调用格式** | XML | OpenAI兼容SDK + 自托管模型，基于提示词方案更通用 |
| **流式处理** | SSE | 更好的用户体验，实时反馈 |
| **状态管理** | Pinia Store | 集中式状态，响应式更新，与Vue深度集成 |
| **任务调度** | CPU Pipeline | 复用现有架构，统一的异步任务管理 |
| **工具执行** | 串行 | 避免依赖冲突，逻辑简单 |
| **错误处理** | 降级策略 | 保证基础功能可用 |
| **用户批准** | 可选功能 | 先实现自动执行，后期可扩展 |

### 10.2 架构优势

**模块化**:
- 每个模块职责单一
- 易于测试和维护
- 可独立升级

**可扩展**:
- 新增工具：只需添加工具实现和描述
- 新增模型：只需调整API客户端
- 新增UI：订阅Store即可

**可维护**:
- 清晰的数据流
- 完善的错误处理
- 详细的日志记录

**高性能**:
- 流式处理减少延迟
- 并发控制避免阻塞
- 缓存策略提升速度

---

## 11. 风险和应对

### 11.1 技术风险

**风险1：XML解析不稳定**
- 表现：模型输出格式错误
- 影响：工具调用失败
- 应对：
  - 完善提示词说明
  - 增加格式验证
  - 提供错误示例让模型学习

**风险2：流式处理中断**
- 表现：网络不稳定导致连接断开
- 影响：对话中断，数据丢失
- 应对：
  - 自动重连机制
  - 保存已接收内容
  - 提供断点续传

**风险3：工具执行失败率高**
- 表现：API调用失败、参数错误
- 影响：用户体验差
- 应对：
  - 详细的错误反馈
  - 参数验证前置
  - 提供修正建议

### 11.2 用户体验风险

**风险1：响应速度慢**
- 表现：流式延迟明显
- 影响：用户感知卡顿
- 应对：
  - 优化网络请求
  - 使用更快的模型
  - 添加加载动画

**风险2：工具调用不准确**
- 表现：模型理解错误，调用错误工具
- 影响：执行非预期操作
- 应对：
  - 优化提示词
  - 添加确认机制
  - 提供撤销功能

**风险3：错误信息不友好**
- 表现：技术错误暴露给用户
- 影响：用户困惑
- 应对：
  - 错误信息人性化
  - 提供操作建议
  - 添加帮助文档

### 11.3 业务风险

**风险1：API成本过高**
- 表现：频繁调用导致费用增加
- 影响：运营成本
- 应对：
  - Token使用限制
  - 缓存常见问答
  - 提供本地模型选项

**风险2：数据安全**
- 表现：敏感信息泄露
- 影响：隐私问题
- 应对：
  - 数据脱敏
  - 本地处理
  - 加密传输

---

## 12. 后续扩展方向

### 12.1 功能扩展

**短期（1-2周）**:
- 添加更多工具（查询统计、批量操作）
- 优化提示词（提高准确率）
- 添加快捷指令（预设场景）

**中期（1-2月）**:
- 支持多模型切换
- 添加语音输入
- 添加图片理解
- 工具批准机制

**长期（3-6月）**:
- 自定义工具系统
- 工作流编排
- 智能建议
- 学习用户习惯

### 12.2 性能扩展

- 本地模型支持（隐私场景）
- 模型微调（提高准确率）
- 缓存优化（减少重复请求）
- 批量处理（提高效率）

### 12.3 集成扩展

- 日历同步
- 第三方服务集成（Notion、Todoist）
- API开放（供其他应用调用）
- 插件系统（社区扩展）

---

## 总结

这是一个完整的、模块化的、可扩展的AI工具调用系统设计方案。

**核心特点**:
- ✅ 基于XML的通用工具调用方案
- ✅ 流式处理提供良好用户体验
- ✅ 与Cutie现有架构深度集成
- ✅ 完善的错误处理和恢复机制
- ✅ 清晰的实施路线图（12天）

**预期效果**:
- 用户可以用自然语言管理任务
- AI能准确理解并执行操作
- 流畅的实时反馈体验
- 稳定可靠的系统运行

现在可以按照这个方案开始实施了！