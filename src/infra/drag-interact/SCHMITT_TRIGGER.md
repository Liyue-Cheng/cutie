# 施密特触发器：防止插入位置抖动

## 🎯 问题描述

### **边界抖动现象**

在拖放排序时，如果鼠标在两个元素的边界附近微小移动，会导致插入位置频繁切换：

```
┌─────────────────┐
│   任务 A        │
├─ ─ ─ ─ ─ ─ ─ ─ ┤  ← 中心线
│                 │  鼠标在这里微小抖动：
└─────────────────┘  120 → 121 → 119 → 122 → 118 ...
                     ↓     ↓     ↓     ↓     ↓
┌─────────────────┐  插入位置闪烁：
│   任务 B        │  1 → 2 → 1 → 2 → 1 ...
├─ ─ ─ ─ ─ ─ ─ ─ ┤  ❌ 预览元素疯狂跳动！
│                 │
└─────────────────┘
```

**原因**：
- 使用单一阈值（中心线）判断
- 鼠标轻微抖动（±1-2px）就会跨越阈值
- 导致插入位置频繁切换

---

## 🔧 解决方案：施密特触发器

### **核心思想**

使用**不同的上下阈值**，根据移动方向选择不同的触发点：

```
向下移动时，需要越过 下沿 (60% 位置)
向上移动时，需要越过 上沿 (40% 位置)
```

这样在 40%-60% 之间形成一个"迟滞区间"，避免频繁切换。

---

## 📊 算法详解

### **施密特触发器原理**

```
┌─────────────────┐
│                 │  ← 卡片顶部 (0%)
│   任务 A        │
│                 │
│    ↓ 40%        │  ← upperThreshold (上沿)
├ ═ ═ ═ ═ ═ ═ ═ ═┤    向上移动需要越过这里
│                 │
│    ↓ 50%        │  ← centerY (中心线，仅首次使用)
│                 │
├ ─ ─ ─ ─ ─ ─ ─ ─ ┤    向下移动需要越过这里
│    ↓ 60%        │  ← lowerThreshold (下沿)
│                 │
│   任务 B        │
│                 │  ← 卡片底部 (100%)
└─────────────────┘
```

**迟滞区间**：40% - 60% (20% 的迟滞)

---

### **状态转换图**

```
初始状态：插入位置 = 1 (任务B之前)
鼠标在 55% 位置（迟滞区间内）

场景1：向下移动
─────────────────────
50% → 55% → 58%
      ↓     ↓
     保持1  保持1  (还没到 60% 下沿)

58% → 62%
      ↓
     切换到2  (越过 60% 下沿！)


场景2：向上移动
─────────────────────
62% → 55% → 42%
      ↓     ↓
     保持2  保持2  (还没到 40% 上沿)

42% → 38%
      ↓
     切换到1  (越过 40% 上沿！)
```

**关键**：在 40%-60% 区间内，插入位置**保持不变**，避免抖动！

---

## 💻 代码实现

### **核心函数**

```typescript
export function calculateDropIndex(
  mouseY: number,
  wrappers: HTMLElement[],
  lastDropIndex?: number  // 🔥 关键：上一次的位置
): number {
  const HYSTERESIS = 0.2 // 20% 迟滞区间

  for (let i = 0; i < wrappers.length; i++) {
    const wrapper = wrappers[i]
    const rect = wrapper.getBoundingClientRect()
    const height = rect.height
    const centerY = rect.top + height / 2

    // 计算上下沿
    const upperThreshold = centerY - height * HYSTERESIS // 40% 位置
    const lowerThreshold = centerY + height * HYSTERESIS // 60% 位置

    // 🔥 施密特触发器逻辑
    if (lastDropIndex !== undefined) {
      if (lastDropIndex <= i) {
        // 向下移动：需要越过下沿
        if (mouseY < lowerThreshold) {
          return i
        }
      } else {
        // 向上移动：需要越过上沿
        if (mouseY < upperThreshold) {
          return i
        }
      }
    } else {
      // 首次计算：使用中心线
      if (mouseY < centerY) {
        return i
      }
    }
  }

  return wrappers.length
}
```

---

### **判断逻辑详解**

#### **向下移动（lastDropIndex <= i）**

```typescript
if (lastDropIndex <= i) {
  // 例如：lastDropIndex = 1, 当前检测 i = 1
  // 说明现在在任务B之前，想要移动到任务C之前
  // 需要越过任务B的下沿 (60%)
  if (mouseY < lowerThreshold) {
    return i
  }
}
```

**含义**：
- 当前在位置 1，想要保持或向下移动
- 只有鼠标**明确越过下沿** (60%) 才认为要插入到这里
- 在 50%-60% 之间：保持原位置，不切换

#### **向上移动（lastDropIndex > i）**

```typescript
} else {
  // 例如：lastDropIndex = 2, 当前检测 i = 1
  // 说明现在在任务C之前，想要移动到任务B之前
  // 需要越过任务B的上沿 (40%)
  if (mouseY < upperThreshold) {
    return i
  }
}
```

**含义**：
- 当前在位置 2，想要向上移动到位置 1
- 只有鼠标**明确越过上沿** (40%) 才认为要插入到这里
- 在 40%-50% 之间：保持原位置，不切换

---

## 📈 效果对比

### **旧算法（单一阈值）**

```
鼠标位置：48% → 49% → 50% → 51% → 52% → 49% → 50% → 51%
           ↓     ↓     ↓     ↓     ↓     ↓     ↓     ↓
插入位置：  1     1     1     2     2     1     1     2
                       ↑ 切换      ↑ 切换      ↑ 切换

❌ 在中心线附近频繁切换！
```

### **新算法（施密特触发器）**

```
鼠标位置：48% → 49% → 50% → 51% → 52% → 49% → 50% → 51%
           ↓     ↓     ↓     ↓     ↓     ↓     ↓     ↓
插入位置：  1     1     1     1     1     1     1     1

继续向下移动...
鼠标位置：52% → 55% → 58% → 60% → 62%
           ↓     ↓     ↓     ↓     ↓
插入位置：  1     1     1     1     2
                                   ↑ 越过 60% 才切换

✅ 在 40%-60% 区间内稳定，不抖动！
```

---

## 🎭 完整场景演示

### **场景1：向下拖动**

```
初始：任务A和B之间 (插入位置 = 1)
鼠标：45% 位置

1. 向下移动到 50%
   lastDropIndex = 1, 当前检测任务B (i=1)
   判断：lastDropIndex (1) <= i (1) ✅ 向下移动
   比较：mouseY (50%) < lowerThreshold (60%) ✅
   结果：返回 1，保持不变 ✅

2. 继续向下移动到 55%
   判断：mouseY (55%) < lowerThreshold (60%) ✅
   结果：返回 1，继续保持 ✅

3. 越过下沿，移动到 62%
   判断：mouseY (62%) < lowerThreshold (60%) ❌
   继续检测下一个...
   结果：返回 2，切换位置 ✅
```

### **场景2：向上拖动**

```
初始：任务B和C之间 (插入位置 = 2)
鼠标：55% 位置

1. 向上移动到 50%
   lastDropIndex = 2, 当前检测任务B (i=1)
   判断：lastDropIndex (2) > i (1) ✅ 向上移动
   比较：mouseY (50%) < upperThreshold (40%) ❌
   结果：继续检测，返回 2，保持不变 ✅

2. 继续向上移动到 45%
   判断：mouseY (45%) < upperThreshold (40%) ❌
   结果：返回 2，继续保持 ✅

3. 越过上沿，移动到 38%
   判断：mouseY (38%) < upperThreshold (40%) ✅
   结果：返回 1，切换位置 ✅
```

---

## 🔬 参数调整

### **迟滞区间大小**

```typescript
const HYSTERESIS = 0.2 // 20% 迟滞区间
```

**调整指南**：

| 迟滞大小 | 触发范围 | 效果 | 适用场景 |
|---------|---------|------|---------|
| 0.1 (10%) | 45%-55% | 响应快，稍有抖动 | 卡片很大时 |
| 0.2 (20%) | 40%-60% | **平衡** ✅ | 一般情况（推荐） |
| 0.3 (30%) | 35%-65% | 非常稳定，响应慢 | 卡片很小时 |

**选择原则**：
- 卡片越小，迟滞越大（用户难以精确控制）
- 卡片越大，迟滞越小（有足够空间精确控制）

---

## 🎯 优势总结

### **1. 消除抖动**

- ✅ 在边界附近微小移动不会导致切换
- ✅ 需要明确的移动意图（越过阈值）才切换
- ✅ 视觉稳定，用户体验好

### **2. 保持响应性**

- ✅ 不是简单的延迟或throttle
- ✅ 大幅度移动时立即响应
- ✅ 只在边界附近有迟滞

### **3. 符合直觉**

- ✅ 向下拖需要"明确下移"才触发
- ✅ 向上拖需要"明确上移"才触发
- ✅ 符合物理世界的"惯性"感觉

---

## 🔍 调试技巧

### **添加调试日志**

```typescript
// 在 calculateDropIndex 中添加
console.log('Schmitt Trigger:', {
  mouseY,
  lastDropIndex,
  currentIndex: i,
  upperThreshold,
  centerY,
  lowerThreshold,
  decision: 'keep' or 'switch'
})
```

### **可视化阈值**

```typescript
// 在开发时显示阈值线
const debugOverlay = document.createElement('div')
debugOverlay.style.position = 'fixed'
debugOverlay.style.left = '0'
debugOverlay.style.right = '0'
debugOverlay.style.height = '2px'
debugOverlay.style.background = 'red'
debugOverlay.style.top = `${upperThreshold}px` // 上沿
// 同理显示 lowerThreshold
```

---

## 📚 参考资料

### **施密特触发器原理**

施密特触发器是一种**迟滞比较器**，广泛应用于：
- 电路设计：消除信号抖动
- 按钮防抖：避免机械开关抖动
- UI 交互：避免边界抖动

**数学模型**：
```
输出状态 = f(输入, 上一次输出)

向上跳变：输入 > 上限阈值
向下跳变：输入 < 下限阈值
保持不变：输入在两个阈值之间
```

这就是我们在拖放排序中应用的相同原理！

---

## ✅ 测试清单

- [ ] 在边界附近微小移动（±2px），插入位置不抖动
- [ ] 向下大幅拖动（>20% 卡片高度），立即响应
- [ ] 向上大幅拖动（>20% 卡片高度），立即响应
- [ ] 在迟滞区间内来回移动，保持稳定
- [ ] 首次进入（无历史位置）使用中心线，正常工作
- [ ] 跨越多个卡片快速移动，正确计算位置

