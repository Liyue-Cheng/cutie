### **《Cutie后端设计纲要》V1.0**

#### **第三部分：外部依赖抽象层 (External Dependency Abstraction Layer)**

*   **层级定义书 (CABC for Layer):**
    *   **预期行为简介:** 本层定义了一系列抽象接口（Rust中的`Trait`），用于隔离核心业务逻辑与所有不确定的、具有副作用的外部依赖（如系统时钟、文件系统、网络API、随机数生成等）。本层**只包含接口定义**，不包含任何具体的实现。
    *   **输入输出规范:**
        *   **前置条件:** 所有依赖本层接口的模块（主要是`服务层`），必须通过依赖注入的方式获取接口的实例。
        *   **后置条件:** 任何实现了本层接口的“适配器”，其行为都必须严格符合接口文档中定义的契约。
    *   **不变量:**
        *   本层的`Trait`定义是稳定的，不应轻易修改。
        *   核心业务逻辑（`服务层`）代码中，**永远不能**直接出现对外部依赖的具体调用（如`Utc::now()`），必须通过本层定义的接口。

---

#### **1. `Clock` (时钟) 接口定义书**

*   **接口签名 (Trait):**
    ```rust
    pub trait Clock: Send + Sync {
        fn now_utc(&self) -> DateTime<Utc>;
    }
    ```
*   **预期行为简介:** 提供获取当前“时刻”的唯一、统一的途径。
*   **函数规范 (`now_utc`):**
    *   **预期行为简介:** 返回当前时间的UTC表示。
    *   **输入输出规范:**
        *   **前置条件:** 无。
        *   **后置条件:** **必须**返回一个`DateTime<Utc>`类型的时间戳。
    *   **边界情况:** 无。
    *   **预期副作用:** 无纯粹的副作用，但其返回值是不确定的（在生产环境中）。

*   **已知适配器:**
    *   `SystemClock`: 生产适配器，其`now_utc`方法内部调用`Utc::now()`。
    *   `FixedClock`: 测试适配器，其`now_utc`方法返回一个在创建时预设的固定时间戳。

---

#### **2. `IdGenerator` (唯一标识符生成器) 接口定义书**

*   **接口签名 (Trait):**
    ```rust
    pub trait IdGenerator: Send + Sync {
        fn new_uuid(&self) -> Uuid;
    }
    ```
*   **预期行为简介:** 提供生成全局唯一标识符（UUID）的唯一途径。
*   **函数规范 (`new_uuid`):**
    *   **预期行为简介:** 返回一个新的、符合UUID规范的唯一标识符。
    *   **输入输出规范:**
        *   **前置条件:** 无。
        *   **后置条件:** **必须**返回一个`Uuid`类型的值。在生产环境中，此值在理论上应是全局唯一的。
    *   **边界情况:** 无。
    *   **预期副作用:** 无纯粹的副作用，但其返回值是不确定的（在生产环境中）。

*   **已知适配器:**
    *   `UuidV4Generator`: 生产适配器，其`new_uuid`方法内部调用`Uuid::new_v4()`。
    *   `SequentialIdGenerator`: 测试适配器，其`new_uuid`方法按预设顺序返回一系列固定的UUID值。

---

#### **3. `SettingRepository` (设置仓库) 接口定义书**

*   **接口签名 (Trait):**
    ```rust
    #[async_trait]
    pub trait SettingRepository: Send + Sync {
        async fn get_setting(&self, key: &str) -> Result<Option<Setting>, DbError>;
        async fn get_all_settings(&self) -> Result<Vec<Setting>, DbError>;
        async fn upsert_setting(&self, setting: &Setting) -> Result<Setting, DbError>;
        async fn delete_setting(&self, key: &str) -> Result<(), DbError>;
    }
    ```
*   **预期行为简介:** 抽象化对用户设置的持久化存储和读取操作。这是对“设置”这一特殊外部依赖的封装。
*   **函数规范 (以`upsert_setting`为例):**
    *   **预期行为简介:** 创建或更新一个设置项。如果具有相同`key`的设置已存在，则更新其`value`和`updated_at`；如果不存在，则创建。
    *   **输入输出规范:**
        *   **前置条件:** 输入的`Setting`对象的`key`不能为空。
        *   **后置条件:** 操作成功后，**必须**返回一个包含最终写入状态（包括更新后的`updated_at`）的`Setting`对象。对该`key`的后续`get_setting`调用必须能返回这个新状态。
    *   **边界情况:**
        *   并发写入：当两个操作同时`upsert`同一个`key`时，最终结果应是“最后写入者获胜”，且存储状态不能损坏。
    *   **预期副作用:** 会修改持久化存储中的状态（无论是文件还是数据库）。

*   **已知适配器:**
    *   `TomlSettingRepository`: V1.0生产适配器，其内部实现对`settings.toml`文件的读写操作。
    *   `(未来) SqlxSettingRepository`: 未来云同步版本的适配器，实现对数据库`settings`表的读写。
    *   `InMemorySettingRepository`: 测试适配器，使用`HashMap`在内存中模拟设置的存储。