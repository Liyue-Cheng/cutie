### **《Cutie单文件组件编写指南》 V1.0**

#### **1. 核心原则**

- **单一职责:** 每个文件只实现**一个**核心业务用例（对应一个API端点）。
- **高内聚:** 与该用例相关的所有代码（文档、路由、验证、业务逻辑、数据库操作）都必须在此文件中。
- **低耦合:** 此文件**严禁**直接`use`或调用项目内其他`feature`文件中的代码。所有共享逻辑必须通过`core`或`shared`模块的抽象来依赖。
- **严格分层:** 文件内部必须遵循清晰的“文档 -> 路由 -> 验证 -> 业务 -> 数据访问”的逻辑分层。

#### **2. 文件结构与命名**

- **文件路径:** `src/features/{domain}/{use_case}.rs` (例如: `src/features/tasks/complete_task.rs`)
- **内部模块:** 文件内部使用`mod`关键字来组织代码，增强可读性。模块名应为：`documentation` (注释形式), `endpoint`, `validation`, `logic`, `database`。

#### **3. 各层编写规范**

##### **3.1. 文档层 (Documentation Layer)**

- **位置:** 文件顶部。
- **格式:** 必须使用多行注释 `/* ... */` 包裹完整的CABC文档。
- **内容:** 必须包含`API端点`, `预期行为简介`, `输入输出规范` (含`前置条件`, `后置条件`, `不变量`), `边界情况`, `预期副作用`, `事务保证`这七个部分。
- **要求:** 必须极其详尽、无歧义，并覆盖所有可预见的场景。

##### **3.2. 路由层 (`endpoint` 模块)**

- **职责:** 仅负责HTTP协议的转换与调度。
- **函数:** 包含一个名为`handle`的`async`函数。
- **参数:** 使用`axum::extract`（如`State`, `Path`, `Json`）来解析请求。必须注入全局的`AppState`。
- **逻辑:**
  1.  **严禁**包含任何业务验证逻辑。
  2.  其唯一的工作是调用本文件内的`logic::execute`函数。
  3.  使用`match`语句处理`logic::execute`返回的`Result`。
  4.  成功时 (`Ok`)，调用`shared::http::error_handler`中的成功响应函数（如`created_response`, `success_response`）来构建`Response`。
  5.  失败时 (`Err`)，直接调用`err.into_response()`来将`AppError`转换为标准错误响应。

##### **3.3. 验证层 (`validation` 模块)**

- **职责:** 验证`endpoint`层传入的请求数据（DTO）是否符合业务规则。
- **函数:** 包含一个或多个**纯函数**（不含`async`, 不访问数据库）。
- **输入:** 接收请求数据DTO的引用（如`&CreateTaskRequest`）。
- **输出:** 返回`Result<(), Vec<ValidationError>>`。
- **逻辑:** 逐一检查所有字段的合法性。如果发现错误，将一个`ValidationError`对象推入错误向量中。最后根据错误向量是否为空返回`Ok`或`Err`。

##### **3.4. 业务层 (`logic` 模块)**

- **职责:** 编排整个业务用例，是功能的核心大脑。
- **函数:** 包含一个名为`execute`的`async`函数。
- **参数:** 接收`&AppState`和经过路由层解析后的数据（如请求DTO或路径参数）。
- **逻辑 (必须遵循此顺序):**
  1.  **调用验证:** 在函数的第一步，必须调用本文件内的`validation`函数。如果验证失败，必须立即返回`AppError::ValidationFailed`。
  2.  **获取外部依赖:** 从`AppState`中获取所有需要的抽象实例，如`clock`, `id_generator`, 以及各个`Repository`的引用。**严禁**直接调用`Utc::now()`或`Uuid::new_v4()`。
  3.  **启动事务:** 如果操作涉及数据库写入，必须调用`app_state.db_pool().begin().await`来启动一个事务。所有后续的数据库操作都必须使用此事务句柄`tx`。
  4.  **执行业务步骤:** 按照CABC文档中“执行过程”的定义，依次调用`database`模块中定义的函数，或`core`中可复用的服务/仓库方法，来完成业务逻辑。
  5.  **提交事务:** 在所有数据库操作成功后，必须调用`tx.commit().await`。
  6.  **错误处理:** 所有可能失败的操作（数据库、IO等）都必须使用`?`操作符或`map_err`，将其错误转换为统一的`AppError`。
  7.  **返回结果:** 返回CABC文档中“后置条件”所承诺的结果。

##### **3.5. 数据访问层 (`database` 模块)**

- **职责:** 封装此功能的数据库查询。
- **函数:** 包含一个或多个`async`函数，用于执行具体的SQL操作。
- **参数:** 如果是写操作，第一个参数**必须**是`&mut Transaction<'_, Sqlite>`。
- **实现:**
  - **必须**使用`sqlx::query_as!`宏来执行所有`SELECT`查询，并将结果映射到`core/domain`中定义的、带有`#[derive(FromRow)]`的`...Row`中间结构体，然后再通过`TryFrom`转换为领域模型。
  - 对于`INSERT`或`UPDATE`操作，推荐使用`RETURNING *`子句配合`query_as!`来获取数据库实际生成/更新的行，以保证数据的一致性。
  - **严禁**在SQL字符串中直接拼接变量，必须使用`?`或`$`占位符进行参数绑定，以防止SQL注入。

---

**示例模板 (伪代码):**

```rust
/* CABC 文档 */

// endpoint 模块
pub mod endpoint {
    pub async fn handle(...) -> Response {
        match logic::execute(...).await { ... }
    }
}

// validation 模块
mod validation {
    pub fn validate_request(...) -> Result<(), Vec<ValidationError>> { ... }
}

// logic 模块
mod logic {
    pub async fn execute(...) -> AppResult<...> {
        validation::validate_request(...)?;
        let clock = app_state.clock();
        let repo = app_state.repo();
        let mut tx = app_state.db_pool().begin().await?;
        database::do_db_operation_1(&mut tx, ...).await?;
        database::do_db_operation_2(&mut tx, ...).await?;
        tx.commit().await?;
        Ok(...)
    }
}

// database 模块
mod database {
    pub async fn do_db_operation_1(...) -> AppResult<...> {
        sqlx::query_as!(...).await
    }
    pub async fn do_db_operation_2(...) -> AppResult<...> {
        sqlx::query!(...).await
    }
}
```

---
