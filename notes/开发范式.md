### **Cutie项目工程纲领：文档驱动开发与行为契约规范**

#### **前言：我们的开发哲学**

在Cutie项目，我们认为软件的“不确定性”是导致Bug、延期和技术债的根源。为了构建一个高质量、可长期演进的产品，我们必须从根本上消除这种不确定性。我们不相信“自觉”，我们相信“纪律”和“体系”。

为此，我们确立了两大核心原则：

1.  **文档是绝对的真实之源 (Documentation as the Absolute Source of Truth):** 软件的行为由其文档唯一确定。代码实现是对文档的忠实翻译。
2.  **变更必须明确且可追溯 (Changes Must Be Explicit and Traceable):** 软件的演进由文档契约的变更驱动，并通过一套严格的语义化版本控制体系来体现。

本纲领旨在将上述哲学转化为一套可执行的、无歧义的工程实践。

---

### **第一部分：CABC (Cutie API Behavior Contract) 规范手册**

**第一条：适用范围**
本规范适用于后端**服务层 (Service Layer)** 的所有**公共方法 (public methods)**。每一个公共方法都必须在代码的文档注释中，提供一份完整的CABC文档。

**第二条：文档结构**
每一份CABC文档必须严格包含以下六个部分：

1.  **函数签名 (Function Signature):**
    *   **内容:** 方法在代码中的完整、精确的函数签名。
    *   **目的:** 提供机器可验证的、最基础的类型契约。

2.  **预期行为简介 (High-Level Behavior):**
    *   **内容:** 一到两句、使用**业务语言**而非技术语言的概括性描述。
    *   **目的:** 让任何阅读者能立刻理解该方法的核心业务意图。

3.  **输入输出规范 (Input/Output Specification - The Contract):**
    *   **内容:** 包含“前置条件”、“后置条件”和“不变量”三个子部分。
    *   **目的:** 采用“契约式设计”思想，精确定义方法的责任边界。
    *   **3.1. 前置条件 (Pre-conditions):**
        *   **定义:** 调用此方法前，输入参数和相关系统状态**必须**满足的条件。
        *   **要求:** 必须穷举所有输入参数的有效域（类型、格式、范围、非空约束等）和依赖的系统状态（如“关联的任务必须存在”）。不满足前置条件是调用者的错误。
    *   **3.2. 后置条件 (Post-conditions):**
        *   **定义:** 如果方法成功执行（不返回错误），系统状态**必须**达到的新状态，以及返回值的确切结构和含义。
        *   **要求:** 必须清晰、可验证。它们将直接转化为测试用例的断言（assertions）。
    *   **3.3. 不变量 (Invariants):**
        *   **定义:** 在方法执行期间及执行完毕后，**永远不能被破坏**的系统级或实体级的规则。
        *   **要求:** 用于声明那些比单个方法更宏观的、必须始终保持一致的系统属性（如“任务的ID和创建时间永远不变”）。

4.  **边界情况 (Edge Cases):**
    *   **内容:** 对所有可预见的“非阳光路径”或特殊输入组合的行为进行明确定义。
    *   **目的:** 消除模糊地带，确保软件在异常情况下的行为是确定和可预测的。
    *   **要求:** **必须**包含对幂等性（重复调用）、无效输入、状态冲突等场景的详细描述。例如：“若任务已完成，再次调用此方法，则必须直接返回成功，不产生任何副作用。”

5.  **预期副作用 (Expected Side Effects):**
    *   **内容:** 明确列出该方法除了返回值之外，对系统产生的**所有**可观测到的影响。
    *   **目的:** 让调用者对一个方法调用的“全部成本”有清晰的认知。
    *   **要求:** 必须包含但不限于：数据库的写操作（增、删、改）、事务的边界、对外部系统（如AI服务）的调用、缓存的失效、消息的推送、日志的记录等。文档末尾隐含一句“无其他已知副作用”。

**第三条：完备性要求**
一份CABC文档被认为是“不完备的”，如果它未能对一种可预见的输入或状态组合的行为做出明确定义。发现“不完备”或“不确定行为”将被视为一个需要进行版本变更的“文档缺陷”。

---

### **第二部分：DDSV (Document-Driven Semantic Versioning) 工作流**

**第四条：核心工作流**
所有新功能开发和Bug修复，都必须遵循“文档先行”的工作流。

*   **对于新功能:** **文档 -> 测试 -> 编码**
    1.  **编写/修改CABC文档**并提交评审。
    2.  根据新文档，编写**将会失败**的测试用例。
    3.  编写功能代码，直到所有测试通过。
*   **对于Bug修复:** **测试 -> 编码 -> 验证文档**
    1.  编写一个能复现该Bug的**失败测试**。
    2.  修改代码实现，使测试通过。
    3.  回溯检查CABC文档。若文档已覆盖此场景，则为`PATCH`。若文档存在疏漏，则升级为`SEMIMAJOR`更新。

**第五条：版本号定义 (`MAJOR.SEMIMAJOR.MINOR.PATCH`)**
软件的版本号由**CABC文档契约的变更**严格驱动。

*   **`MAJOR` (X.y.z.a -> (X+1).0.0.0): 破坏性文档更新**
    *   **定义:** 对已发布的CABC或OpenAPI文档进行了**破坏性的更新**，导致现有客户端不经修改就无法正常工作。
    *   **示例:** 移除API端点；修改参数类型；将成功行为改为错误行为。

*   **`SEMIMAJOR` (x.Y.z.a -> x.(Y+1).0.0): 非破坏性文档勘误**
    *   **定义:** 发现现有CABC文档存在**不确定行为（Undefined Behavior）**，通过更新文档来明确其行为。
    *   **示例:** 明确定义了对`null`或空字符串输入的处理方式；明确定义了幂等操作的行为。

*   **`MINOR` (x.y.Z.a -> x.y.(Z+1).0): 非破坏性文档扩展**
    *   **定义:** 对CABC或OpenAPI文档进行了**向后兼容**的功能性扩展。
    *   **示例:** 新增API端点；为请求体增加可选参数；为响应体增加新字段。

*   **`PATCH` (x.y.z.A -> x.y.z.(A+1)): 纯代码实现修复**
    *   **定义:** 代码实现**不符合**现有CABC文档的明确定义，通过修改代码来使其符合文档。文档本身不发生任何语义变更。
    *   **示例:** 文档承诺返回404，代码却返回500；文档承诺清理未来日程，代码遗漏了此逻辑。

**第六条：实施与评审**
所有代码和文档的变更都必须通过Pull Request机制进行。Code Review的首要任务，是将代码实现与对应的CABC文档进行逐一比对。任何与文档不符或文档未定义的实现，都将被拒绝合并，直到代码或文档得到修正（并可能触发相应的版本号变更）。