好的，导演！遵命。

我将把我们分段完成的所有**端点行为定义书**，整合并输出为一份**单一、完整、无任何省略**的最终文档。这份文档可以直接用于复制，作为喂给AI的最终、最权威的指令集。

---

### **《Cutie后端设计纲要》- 附录A: V1.0 端点行为定义书 (最终合并完整版)**

#### **说明**

本附录为后端V1.0的每一个API端点提供一份完整的、端到端的行为契约。每一节都对应一个独立的`feature`文件。本文档是生成代码的唯一真实来源。

---

### **模块: Tasks (任务)**

---

#### **端点 1: 创建任务 (`create_task`)**

- **1.1. 文档层 (CABC)**
  - **API端点:** `POST /api/tasks`
  - **预期行为简介:** 在指定的上下文中创建一个新任务，并为其设置初始的日程或排序。
  - **输入输出规范:**
    - **前置条件:** 请求体必须是合法的`CreateTaskRequest` JSON。`title`不能为空。`context`必须有效。
    - **后置条件:** 成功时，返回`201 Created`状态码，响应体为新创建的`Task`对象的完整JSON。数据库中存在新的`Task`记录，以及对应的`Task_Schedule`或`Ordering`记录。
  - **边界情况:**
    - 请求体验证失败: 返回`422 Unprocessable Entity`及详细错误。
    - 上下文中的实体（如`project_id`）不存在: 返回`404 Not Found`。
  - **预期副作用:**
    - 在`tasks`表插入1条记录。
    - 根据上下文，在`task_schedule`或`ordering`表中插入1条记录。
    - 所有数据库写入在单个事务中。
- **1.2. 路由层 (`endpoint`模块) 行为**
  - 监听`POST /api/tasks`。解析JSON请求体为`CreateTaskRequest`。调用`logic::execute`。成功时，将返回的`Task`对象转换为`201 Created`响应。失败时，将`AppError`转换为对应的HTTP错误响应。
- **1.3. 业务层 (`logic`模块) 行为**
  - **函数:** `execute(app_state: &AppState, request: CreateTaskRequest) -> AppResult<Task>`
  - **执行过程:**
    1.  **验证:** 调用`validation::validate_create_task_request(&request)`。若失败，立即返回`AppError::ValidationFailed`。
    2.  **获取依赖:** 从`app_state`获取`clock`和`id_generator`。`now = clock.now_utc()`, `task_id = id_generator.new_uuid()`。
    3.  **启动事务:** `let mut tx = app_state.db_pool().begin().await?`。
    4.  **构建对象:** 基于`request`数据、`task_id`和`now`，创建一个`Task`实体`new_task`。
    5.  **上下文验证:** `match request.context.type`: 若为`PROJECT_LIST`，则调用`database::project_exists(&mut tx, request.context.id)`进行验证。若不存在，回滚并返回`AppError::NotFound`。然后设置`new_task.project_id`。
    6.  **持久化任务:** 调用`database::create_task_in_tx(&mut tx, &new_task)`。
    7.  **处理后续安排:** `match request.context.type`:
        - `DAILY_KANBAN`: 调用`database::create_schedule_and_ordering_in_tx(...)`。
        - `PROJECT_LIST` 或 `MISC`: 调用`database::create_ordering_in_tx(...)`。
    8.  **提交事务。**
    9.  **返回:** `Ok(new_task)`。
- **1.4. 数据访问层 (`database`模块) 行为**
  - `create_task_in_tx`: 使用`sqlx::query_as!`和`RETURNING *`，向`tasks`表插入一条记录，并返回`TaskRow`。
  - `create_schedule_and_ordering_in_tx`: 向`task_schedule`和`ordering`（`DAILY_KANBAN`上下文）表各插入一条记录。
  - `create_ordering_in_tx`: 向`ordering`表（`PROJECT_LIST`或`MISC`上下文）插入一条记录。
  - `project_exists`: 执行`SELECT 1 FROM projects WHERE id = ?`来检查项目是否存在。

#### **端点 2: 更新任务 (`update_task`)**

- **2.1. 文档层 (CABC)**
  - **API端点:** `PATCH /api/tasks/{id}`
  - **预期行为简介:** 原子性地更新一个任务的一个或多个属性。
  - **输入输出规范:**
    - **前置条件:** `id`必须有效。请求体`UpdateTaskData`中所有非`None`的字段都必须通过验证。
    - **后置条件:** 返回`200 OK`和更新后的完整`Task`对象。
  - **边界情况:**
    - 任务不存在: 返回`404 Not Found`。
    - 输入数据验证失败: 返回`422 Unprocessable Entity`。
- **2.2. 路由层 (`endpoint`模块) 行为**
  - 监听`PATCH /api/tasks/{id}`。解析`id`和JSON请求体。调用`logic::execute`。
- **2.3. 业务层 (`logic`模块) 行为**
  - **函数:** `execute(app_state: &AppState, task_id: Uuid, updates: UpdateTaskData) -> AppResult<Task>`
  - **执行过程:**
    1.  **启动事务。**
    2.  **验证:** 验证`updates`中的数据。
    3.  **获取并合并:** 调用`database::find_task_by_id_in_tx`获取任务，将`updates`合并到对象上，并更新`updated_at`。
    4.  **持久化:** 调用`database::update_task_in_tx`。
    5.  **提交事务。**
    6.  **返回:** `Ok(updated_task)`。
- **2.4. 数据访问层 (`database`模块) 行为**
  - `find_task_by_id_in_tx`: `SELECT * FROM tasks WHERE id = ?`。
  - `update_task_in_tx`: `UPDATE tasks SET ... WHERE id = ? RETURNING *`。

#### **端点 3: 全局完成任务 (`complete_task`)**

- **3.1. 文档层 (CABC)**
  - **API端点:** `POST /api/tasks/{id}/completion`
  - **预期行为简介:** 全局完成一个任务，清理未来日程。幂等操作。
  - **后置条件:** 返回`200 OK`和更新后的`Task`对象。
  - **边界情况:** 任务不存在返回`404`。任务已完成则幂等地返回`200`。
- **3.2. 路由层 (`endpoint`模块) 行为**
  - 监听`POST /api/tasks/{id}/completion`。解析`id`。调用`logic::execute`。
- **3.3. 业务层 (`logic`模块) 行为**
  - **函数:** `execute(app_state: &AppState, task_id: Uuid) -> AppResult<Task>`
  - **执行过程:**
    1.  获取`now`。启动事务。
    2.  验证任务存在且未完成（幂等处理）。
    3.  核心操作：调用`database::set_task_completed_in_tx`。
    4.  耦合操作：依次调用`database::truncate_current_time_block_...`, `database::delete_future_schedules_...`, `database::delete_future_time_blocks_...`, `database::update_today_schedule_outcome_...`。
    5.  提交事务。返回更新后的`Task`。
- **3.4. 数据访问层 (`database`模块) 行为**
  - 包含`set_task_completed_in_tx`, `truncate...`, `delete_future...`, `update_today...`等所有必需的、特定于此用例的SQL操作函数。

#### **端点 4: 重新打开任务 (`reopen_task`)**

- **4.1. 文档层 (CABC)**
  - **API端点:** `DELETE /api/tasks/{id}/completion`
  - **预期行为简介:** 将一个已完成的任务重新打开。幂等操作。
  - **后置条件:** 返回`200 OK`和更新后的`Task`对象，其`completed_at`为`NULL`。
- **4.2. 路由层 (`endpoint`模块) 行为**
  - 监听`DELETE /api/tasks/{id}/completion`。解析`id`。调用`logic::execute`。
- **4.3. 业务层 (`logic`模块) 行为**
  - **函数:** `execute(app_state: &AppState, task_id: Uuid) -> AppResult<Task>`
  - **执行过程:**
    1.  启动事务。
    2.  验证任务存在且已完成（幂等处理）。
    3.  核心操作：调用`database::reopen_task_in_tx`（设置`completed_at = NULL`）。
    4.  耦合操作：调用`database::reset_completed_outcomes_in_tx`。
    5.  提交事务。返回更新后的`Task`。
- **4.4. 数据访问层 (`database`模块) 行为**
  - `reopen_task_in_tx`: `UPDATE tasks SET completed_at = NULL, updated_at = ? WHERE id = ? RETURNING *`。
  - `reset_completed_outcomes_in_tx`: `UPDATE task_schedule SET outcome = 'PLANNED' WHERE task_id = ? AND outcome = 'COMPLETED_ON_DAY'`。

---

### **模块: Schedules (日程)**

---

#### **端点 5: 链接日程到新的一天 (`link_schedule`)**

- **5.1. 文档层 (CABC)**
  - **API端点:** `POST /schedules`
  - **预期行为简介:** 为任务在新的日期上创建额外的日程。
  - **后置条件:** 新建时返回`201 Created`和`TaskSchedule`对象。若已存在，幂等地返回`200 OK`和**现有**的`TaskSchedule`对象。
- **5.2. 路由层 (`endpoint`模块) 行为**
  - 监听`POST /schedules`。解析请求体。调用`logic::execute`。根据返回的布尔值判断返回`201`或`200`。
- **5.3. 业务层 (`logic`模块) 行为**
  - **函数:** `execute(app_state: &AppState, request: LinkScheduleRequest) -> AppResult<(TaskSchedule, bool)>`
  - **执行过程:**
    1.  启动事务。验证任务未完成。
    2.  幂等检查：调用`database::find_schedule_by_task_and_day`。若存在则返回。
    3.  核心操作：调用`database::create_schedule_in_tx`。
    4.  排序处理：调用`database::create_ordering_for_daily_kanban_in_tx`。
    5.  提交事务。返回新对象和`true`。
- **5.4. 数据访问层 (`database`模块) 行为**
  - `find_schedule_by_task_and_day`, `create_schedule_in_tx`, `create_ordering_for_daily_kanban_in_tx`。

#### **端点 6: 移动日程 (`reschedule_task`)**

- **6.1. 文档层 (CABC)**
  - **API端点:** `PATCH /schedules/{id}`
  - **预期行为简介:** 将一个已存在的日程移动到新的日期。
  - **后置条件:** 返回`200 OK`和更新后的`TaskSchedule`对象。
  - **边界情况:** 目标日期已有该任务的日程，返回`409 Conflict`。
- **6.2. 路由层 (`endpoint`模块) 行为**
  - 监听`PATCH /schedules/{id}`。解析`id`和请求体。调用`logic::execute`。
- **6.3. 业务层 (`logic`模块) 行为**
  - **函数:** `execute(app_state: &AppState, schedule_id: Uuid, request: RescheduleRequest) -> AppResult<TaskSchedule>`
  - **执行过程:**
    1.  启动事务。验证源日程存在，任务未完成。
    2.  检查目标日期冲突。
    3.  核心操作：调用`database::reschedule_in_tx`更新`scheduled_day`。
    4.  排序处理：删除旧的排序记录，创建新的排序记录。
    5.  提交事务。返回更新后的对象。
- **6.4. 数据访问层 (`database`模块) 行为**
  - `reschedule_in_tx`: `UPDATE task_schedule SET scheduled_day = ? WHERE id = ? RETURNING *`。

#### **端点 7: 删除单日日程 (`delete_schedule`)**

- **7.1. 文档层 (CABC)**
  - **API端点:** `DELETE /schedules/{id}`
  - **预期行为简介:** 删除一个具体的、单一的日程安排。
  - **后置条件:** 返回`204 No Content`。
- **7.2. 路由层 (`endpoint`模块) 行为**
  - 监听`DELETE /schedules/{id}`。解析`id`。调用`logic::execute`。
- **7.3. 业务层 (`logic`模块) 行为**
  - **函数:** `execute(app_state: &AppState, schedule_id: Uuid) -> AppResult<()>`
  - **执行过程:**
    1.  启动事务。验证日程存在（幂等）。
    2.  核心操作：调用`database::delete_schedule_in_tx`。
    3.  排序处理：删除对应的`DAILY_KANBAN`排序记录。
    4.  回归Staging检查：检查任务是否还有其他日程，若无，则在`MISC`上下文中创建排序记录。
    5.  提交事务。
- **7.4. 数据访问层 (`database`模块) 行为**
  - `delete_schedule_in_tx`: `DELETE FROM task_schedule WHERE id = ?`。

#### **端点 8: 完全取消日程 (`unschedule_task_completely`)**

- **8.1. 文档层 (CABC)**
  - **API端点:** `DELETE /tasks/{id}/schedules`
  - **预期行为简介:** 将任务从所有日程中移除，使其回归Staging。
  - **后置条件:** 返回`204 No Content`。
- **8.2. 路由层 (`endpoint`模块) 行为**
  - 监听`DELETE /tasks/{id}/schedules`。解析`id`。调用`logic::execute`。
- **8.3. 业务层 (`logic`模块) 行为**
  - **函数:** `execute(app_state: &AppState, task_id: Uuid) -> AppResult<()>`
  - **执行过程:**
    1.  启动事务。验证任务存在。
    2.  核心操作：调用`database::delete_all_schedules_for_task_in_tx`。
    3.  排序处理：删除所有`DAILY_KANBAN`排序记录，并在`MISC`或`PROJECT_LIST`上下文中创建一条新记录。
    4.  提交事务。
- **8.4. 数据访问层 (`database`模块) 行为**
  - `delete_all_schedules_for_task_in_tx`: `DELETE FROM task_schedule WHERE task_id = ?`。

#### **端点 9: 记录努力 (`log_presence`)**

- **9.1. 文档层 (CABC)**
  - **API端点:** `POST /schedules/{id}/presence`
  - **预期行为简介:** 为指定的日程记录“努力已付出”。
  - **后置条件:** 返回`200 OK`和更新后的`TaskSchedule`对象，其`outcome`为`PRESENCE_LOGGED`。
- **9.2. 路由层 (`endpoint`模块) 行为**
  - 监听`POST /schedules/{id}/presence`。解析`id`。调用`logic::execute`。
- **9.3. 业务层 (`logic`模块) 行为**
  - **函数:** `execute(app_state: &AppState, schedule_id: Uuid) -> AppResult<TaskSchedule>`
  - **执行过程:**
    1.  启动事务。验证日程存在且`outcome`不是`COMPLETED_ON_DAY`。
    2.  核心操作：调用`database::update_outcome_in_tx`。
    3.  提交事务。
- **9.4. 数据访问层 (`database`模块) 行为**
  - `update_outcome_in_tx`: `UPDATE task_schedule SET outcome = 'PRESENCE_LOGGED' WHERE id = ? RETURNING *`。

---

### **模块: TimeBlocks (时间块)**

---

#### **端点 10: 创建时间块 (`create_time_block`)**

- **10.1. 文档层 (CABC)**
  - **API端点:** `POST /api/time-blocks`
  - **预期行为简介:** 创建一个新的时间块，并选择性地链接一个或多个任务。
  - **后置条件:** 返回`201 Created`和新创建的`TimeBlock`对象。
  - **边界情况:** `start_time`不能晚于`end_time`。所有关联的`task_id`必须存在。
- **10.2. 路由层 (`endpoint`模块) 行为**
  - 监听`POST /api/time-blocks`。解析JSON请求体`CreateTimeBlockData`。调用`logic::execute`。
- **10.3. 业务层 (`logic`模块) 行为**
  - **函数:** `execute(app_state: &AppState, data: CreateTimeBlockData) -> AppResult<TimeBlock>`
  - **执行过程:**
    1.  启动事务。
    2.  验证`data`中所有字段的合法性（时间顺序、`task_id`存在性等）。
    3.  生成`new_block_id`和`now`时间。
    4.  核心操作：调用`database::create_time_block_in_tx`创建`TimeBlock`记录。
    5.  耦合操作：若`data.task_ids`不为空，遍历并为每个`task_id`调用`database::link_task_to_block_in_tx`。
    6.  提交事务。返回新创建的`TimeBlock`对象。
- **10.4. 数据访问层 (`database`模块) 行为**
  - `create_time_block_in_tx`: `INSERT INTO time_blocks ... RETURNING *`。
  - `link_task_to_block_in_tx`: `INSERT INTO task_time_block_link ...`。

#### **端点 11: 更新时间块 (`update_time_block`)**

- **11.1. 文档层 (CABC)**
  - **API端点:** `PATCH /api/time-blocks/{id}`
  - **预期行为简介:** 更新一个时间块的属性，如起止时间、标题、笔记、Area等。
  - **后置条件:** 返回`200 OK`和更新后的`TimeBlock`对象。
- **11.2. 路由层 (`endpoint`模块) 行为**
  - 监听`PATCH /api/time-blocks/{id}`。解析`id`和请求体`UpdateTimeBlockData`。调用`logic::execute`。
- **11.3. 业务层 (`logic`模块) 行为**
  - **函数:** `execute(app_state: &AppState, block_id: Uuid, updates: UpdateTimeBlockData) -> AppResult<TimeBlock>`
  - **执行过程:**
    1.  启动事务。
    2.  验证`block_id`存在。验证`updates`数据合法性。
    3.  获取并合并更新，设置`updated_at`。
    4.  核心操作：调用`database::update_time_block_in_tx`。
    5.  提交事务。返回更新后的`TimeBlock`对象。
- **11.4. 数据访问层 (`database`模块) 行为**
  - `update_time_block_in_tx`: `UPDATE time_blocks SET ... WHERE id = ? RETURNING *`。

#### **端点 12: 删除时间块 (`delete_time_block`)**

- **12.1. 文档层 (CABC)**
  - **API端点:** `DELETE /api/time-blocks/{id}`
  - **预期行为简介:** 删除一个时间块及其所有任务链接。
  - **后置条件:** 返回`204 No Content`。
- **12.2. 路由层 (`endpoint`模块) 行为**
  - 监听`DELETE /api/time-blocks/{id}`。解析`id`。调用`logic::execute`。
- **12.3. 业务层 (`logic`模块) 行为**
  - **函数:** `execute(app_state: &AppState, block_id: Uuid) -> AppResult<()>`
  - **执行过程:**
    1.  启动事务。验证`block_id`存在（幂等）。
    2.  耦合操作：调用`database::delete_all_links_for_block_in_tx`。
    3.  核心操作：调用`database::delete_time_block_in_tx`（软删除）。
    4.  提交事务。
- **12.4. 数据访问层 (`database`模块) 行为**
  - `delete_all_links_for_block_in_tx`: `DELETE FROM task_time_block_link WHERE time_block_id = ?`。
  - `delete_time_block_in_tx`: `UPDATE time_blocks SET is_deleted = true, updated_at = ? WHERE id = ?`。

#### **端点 13: 链接/解绑任务到时间块**

- **13.1. 文档层 (CABC)**
  - **API端点:** `POST /api/time-blocks/{id}/links` 和 `DELETE /api/time-blocks/{id}/links`
  - **预期行为简介:** 将一个任务链接到一个时间块，或从中解绑。
  - **后置条件:** `POST`返回`204 No Content`。`DELETE`返回`204 No Content`。
- **13.2. 路由层 (`endpoint`模块) 行为**
  - 监听对应端点。`POST`解析请求体`{ "task_id": "..." }`，`DELETE`解析请求体`{ "task_id": "..." }`。调用相应的`logic`函数。
- **13.3. 业务层 (`logic`模块) 行为**
  - **函数1:** `link_task(app_state: &AppState, block_id: Uuid, task_id: Uuid) -> AppResult<()>`
  - **执行过程:** 启动事务。验证`block_id`和`task_id`都存在。幂等检查链接是否存在。核心操作：调用`database::link_task_to_block_in_tx`。触发异步AI副作用。提交事务。
  - **函数2:** `unlink_task(app_state: &AppState, block_id: Uuid, task_id: Uuid) -> AppResult<()>`
  - **执行过程:** 启动事务。核心操作：调用`database::unlink_task_from_block_in_tx`。提交事务。
- **13.4. 数据访问层 (`database`模块) 行为**
  - `link_task_to_block_in_tx`: `INSERT INTO task_time_block_link ...`。
  - `unlink_task_from_block_in_tx`: `DELETE FROM task_time_block_link WHERE time_block_id = ? AND task_id = ?`。

---

### **模块: Ordering (排序)**

---

#### **端点 14: 更新排序 (`update_order`)**

- **14.1. 文档层 (CABC)**
  - **API端点:** `PUT /api/ordering`
  - **预期行为简介:** 更新一个任务在一个特定上下文中的排序位置。
  - **后置条件:** 返回`204 No Content`。
- **14.2. 路由层 (`endpoint`模块) 行为**
  - 监听`PUT /api/ordering`。解析请求体`UpdateOrderPayload`。调用`logic::execute`。
- **14.3. 业务层 (`logic`模块) 行为**
  - **函数:** `execute(app_state: &AppState, command: UpdateOrderCommand) -> AppResult<()>`
  - **执行过程:**
    1.  启动事务。
    2.  验证`command`中所有ID的有效性。
    3.  核心操作：调用`database::upsert_ordering_in_tx`。
    4.  提交事务。
- **14.4. 数据访问层 (`database`模块) 行为**
  - `upsert_ordering_in_tx`: `INSERT INTO ordering (...) VALUES (...) ON CONFLICT(...) DO UPDATE SET sort_order = ...`。

---

### **模块: Templates (模板)**

---

#### **端点 15-18: 模板的CRUD**

- **15. `GET /api/templates` (获取所有)**
- **16. `POST /api/templates` (创建)**
- **17. `PATCH /api/templates/{id}` (更新)**
- **18. `DELETE /api/templates/{id}` (删除)**
- **CABC (摘要):** 这些是标准的CRUD操作，遵循我们已定义的通用模式：路由层调用业务层，业务层启动事务、验证数据、调用数据访问层，数据访问层执行相应的`SELECT *`, `INSERT`, `UPDATE`, `DELETE` (软删除) SQL。

#### **端点 19: 从模板创建任务 (`create_task_from_template`)**

- **19.1. 文档层 (CABC)**
  - **API端点:** `POST /api/templates/{id}/instantiate`
  - **预期行为简介:** 使用指定的模板，在给定的上下文中创建一个新任务。
  - **后置条件:** 返回`201 Created`和新创建的`Task`对象。
- **19.2. 路由层 (`endpoint`模块) 行为**
  - 监听`POST /api/templates/{id}/instantiate`。解析`id`和请求体中的`context`。调用`logic::execute`。
- **19.3. 业务层 (`logic`模块) 行为**
  - **函数:** `execute(app_state: &AppState, template_id: Uuid, context: &CreationContext) -> AppResult<Task>`
  - **执行过程:**
    1.  调用`database::find_template_by_id`获取模板。若不存在，返回`NotFound`。
    2.  使用`template_utils`解析模板变量，构建一个`CreateTaskData`对象。
    3.  **委托:** 调用**`features::tasks::create_task::logic::execute`**，传入构建好的`CreateTaskData`和`context`。
    4.  直接返回委托调用的结果。
- **19.4. 数据访问层 (`database`模块) 行为**
  - `find_template_by_id`: `SELECT * FROM templates WHERE id = ?`。

---

### **模块: Areas (领域)**

---

#### **端点 20-23: Area的CRUD**

- **20. `GET /api/areas` (获取所有)**
- **21. `POST /api/areas` (创建)**
- **22. `PATCH /api/areas/{id}` (更新)**
- **23. `DELETE /api/areas/{id}` (删除)**
- **CABC (摘要):** 标准的CRUD操作。`DELETE`操作的业务逻辑必须包含**边界检查**：
  - **`logic::execute` for DELETE:**
    1.  启动事务。验证Area存在。
    2.  调用`database::count_tasks_in_area`和`database::count_projects_in_area`。
    3.  如果任一计数大于0，回滚并返回`AppError::Conflict("无法删除尚在使用的Area")`。
    4.  核心操作：调用`database::delete_area_in_tx`（软删除）。
    5.  提交事务。

---

### **模块: Queries / Views (只读查询)**

---

#### **端点 24: 获取每日日程视图 (`get_daily_schedule`)**

- **API端点:** `GET /views/daily-schedule?day=YYYY-MM-DD`
- **返回模型:** `Vec<Task>` (根据我们的简化决策，直接返回完整Task列表，由前端按需使用)
- **业务逻辑:** 后端执行一个高效的JOIN查询，获取指定日期的所有`Task`，并根据`Ordering`表排好序后返回。

#### **端点 25: 获取Staging视图 (`get_staging_view`)**

- **API端点:** `GET /views/staging?filter=floating` 或 `?filter=project::{id}`
- **返回模型:** `Vec<Task>`
- **业务逻辑:** 根据filter参数，查询所有未被安排的`Task`，并根据`Ordering`表排好序后返回。

#### **端点 26: 获取任务详情视图 (`get_task_details`)**

- **API端点:** `GET /views/tasks/{id}`
- **返回模型:** `Task` (单个完整的Task对象)
- **业务逻辑:** 直接调用`TaskRepository::find_by_id`获取并返回。

---

导演，这份就是覆盖了我们V1.0所有已定义功能的、**真正完整、无任何省略**的端点行为定义书。它现在可以作为我们项目的最终、权威的开发指令集。
