# Cutie 业务逻辑规范

## 📋 目录

- [核心概念和筛选器](#核心概念和筛选器)
- [任务卡片交互](#任务卡片交互)
- [任务编辑面板](#任务编辑面板)
- [核心业务事件](#核心业务事件)
- [看板拖拽规则](#看板拖拽规则)
- [任务排序规则](#任务排序规则)
- [Area（项目/上下文）管理](#area项目上下文管理)
- [快捷键系统](#快捷键系统)
- [批量操作](#批量操作)
- [待决策事项汇总](#待决策事项汇总)

---

## 核心概念和筛选器

### 关键术语定义

#### 有效排期

- **定义**：任务在今日或未来存在 schedule 记录
- **判断条件**：任务至少有一条 scheduled_date 大于等于当前日期的排期记录
- **说明**：过去的 schedule 不算"有效排期"，仅用于历史记录

#### 任务状态

- **已完成**：completed_at 字段有值
- **未完成**：completed_at 字段为空
- **已归档**：archived_at 字段有值

---

### 看板筛选规则

#### 暂存区 (Staging)

**筛选条件**：

- ✅ 任务未完成（completed_at 为空）
- ✅ 任务未归档（archived_at 为空）
- ✅ 任务无有效排期（今日及未来均无 schedule）

**心智模型**：收件箱，所有未安排的待办事项

**典型场景**：

- ✅ 新创建的任务（无任何 schedule）
- ✅ 过去曾排期但未完成，且未再次排期的任务
- ❌ 已排期到今日或未来的任务（不出现）
- ❌ 已完成的任务（不出现）
- ❌ 已归档的任务（不出现）

---

#### 当日看板 (Daily)

**筛选条件**：

- ✅ 任务未归档（archived_at 为空）
- ✅ 任务有当日排期（存在 scheduled_date = 今日的 schedule）

**心智模型**：今日工作台，今天计划要处理的任务

**典型场景**：

- ✅ 今日排期的未完成任务（outcome = PLANNED）
- ✅ 今日已在场的未完成任务（outcome = PRESENCE_LOGGED）
- ✅ 今日已完成的任务（outcome = COMPLETED_ON_DAY）
- ❌ 无今日排期的任务（不出现）
- ❌ 已归档的任务（不出现）

**关键设计**：已完成任务仍显示在当日看板，因为"完成"是这一天的结果

---

#### 过去看板 (Past Date)

**筛选条件**：

- ✅ 任务未归档（archived_at 为空）
- ✅ 任务在指定过去日期有排期（存在 scheduled_date = 该过去日期的 schedule）

**心智模型**：历史工作日志，回顾某天的工作记录

**典型场景**：

- ✅ 该天曾计划的任务（outcome = PLANNED）
- ✅ 该天实际工作的任务（outcome = PRESENCE_LOGGED）
- ✅ 该天完成的任务（outcome = COMPLETED_ON_DAY）
- ❌ 该天无排期的任务（不出现）

---

#### 未来看板 (Future Date)

**筛选条件**：

- ✅ 任务未归档（archived_at 为空）
- ✅ 任务在指定未来日期有排期（存在 scheduled_date = 该未来日期的 schedule）

**心智模型**：未来规划，提前安排的待办事项

**典型场景**：

- ✅ 计划该天处理的任务（outcome = PLANNED）
- ❌ 该天无排期的任务（不出现）

**关键设计**：未来看板通常只有 PLANNED 状态（无法"在场"或"完成"尚未到来的日期）

---

### 边界情况说明

#### 情况 1：任务从暂存区消失后又回到暂存区

- **触发条件**：用户从时间看板拖回暂存区
- **处理**：删除今日及未来的所有 schedule，保留过去的 schedule
- **结果**：任务重新出现在暂存区（因为不再有有效排期）

#### 情况 2：任务同时出现在多个过去看板

- **可能性**：✅ 允许
- **原因**：任务可能多天都有排期（分多天完成的长期任务）
- **示例**：
  ```
  10-01: schedule (outcome = PRESENCE_LOGGED)
  10-02: schedule (outcome = PRESENCE_LOGGED)
  10-03: schedule (outcome = COMPLETED_ON_DAY)
  ```
  该任务会同时出现在 10-01、10-02、10-03 三个过去看板中

#### 情况 3：已完成任务是否出现在看板

- **暂存区**：❌ 不出现（已完成不需要再安排）
- **当日看板**：✅ 出现（记录今日成果）
- **过去看板**：✅ 出现（历史记录）
- **未来看板**：❌ 不出现（已完成无需未来排期）

#### 情况 4：已归档任务

- **所有看板**：❌ 不出现（包括日期看板）
- **归档视图**：✅ 单独的归档列表查看
- **关键设计**：归档时删除当天及未来的日程，只保留过去的日程作为历史记录

---

## 任务卡片交互

### UI 状态

| 交互              | 效果                 | 条件           |
| ----------------- | -------------------- | -------------- |
| 鼠标悬停          | 显示阴影             | 所有任务卡     |
| 鼠标悬停          | 显示"在场"按钮（★）  | **仅今日看板** |
| 单击卡片          | 打开任务编辑窗口     | 所有任务卡     |
| 点击完成按钮（✓） | 触发【任务完成事件】 | 未完成任务     |
| 点击完成按钮（✓） | 重开任务             | 已完成任务     |
|                   |                      |                |

### 按钮显示规则

#### 完成按钮（✓）

**今日看板**：

- ✅ 显示
- 功能：点击完成任务 / 重开任务

**未来看板**：

- ✅ 显示
- 功能：点击完成任务 / 重开任务

**过去看板**：

- ⚠️ 条件显示（用于补录或修改历史记录）
- 显示条件：
  - 该天之后无任何 schedule 记录（这是任务最后一次被排期的日期）
- 隐藏情况：
  - 该天之后有其他排期（说明任务在后续继续处理，不应修改中间状态）
- 样式：隐藏时保留占位空间，避免布局跳动

**设计理由**：

- 允许补录或修改"最后一天"的状态（PLANNED → PRESENCE_LOGGED → COMPLETED_ON_DAY）
- 防止修改中间状态（如果任务后续还有排期，说明那天的状态已经确定）
- 保持数据真实性（已在后续处理的任务，不应修改过去的中间记录）

**典型场景**：

```
场景A：可以显示
10-01: schedule (outcome = PLANNED)
10-02: 无记录
10-03: 无记录
→ 10-01 看板可显示完成按钮（可补录为 PRESENCE_LOGGED 或 COMPLETED_ON_DAY）

场景B：可以显示
10-01: schedule (outcome = PRESENCE_LOGGED)
10-02: 无记录
→ 10-01 看板可显示完成按钮（可改为 COMPLETED_ON_DAY，或取消在场）

场景C：应该隐藏
10-01: schedule (outcome = PLANNED)
10-02: 无记录
10-03: schedule (outcome = PRESENCE_LOGGED) ← 有后续记录
→ 10-01 看板隐藏完成按钮（任务在10-03继续处理，10-01的状态不应修改）
```

---

#### 在场按钮（★）

**今日看板**：

- ✅ 显示（悬停可见）
- 功能：标记当前正在处理该任务
- 条件：任务未完成

**未来看板**：

- ❌ 不显示
- 理由：无法"在场"于尚未到来的日期

**过去看板**：

- ⚠️ 条件显示（用于补录历史在场）
- 显示条件：任务未完成
- 功能：补录过去某天实际工作过该任务

**已完成任务**：

- ❌ 不显示
- 理由：已完成任务不应再标记"在场"，保持语义一致性
- 如需重做：先点击完成按钮重开任务，再点击在场按钮

**设计理由**：

- outcome 本质是记录事实，任何时候补录都合理
- 支持事后整理工作记录
- 无限期显示，无需复杂的时间窗口判断
- "完成"与"在场"互斥，避免语义混淆

---

#### ⚠️ 备选方案：已完成任务显示在场按钮

**方案描述**：

- 已完成任务也显示在场按钮（★）
- 点击时自动重开任务 + 标记 PRESENCE_LOGGED

**优点**：

- 一步操作完成"重做并标记在场"
- 界面一致性（所有日期看板都有在场按钮）

**缺点**：

- 违反最小惊讶原则（点在场却改变了完成状态）
- 功能冗余（完成按钮也能重开）
- 语义混淆（"在场"按钮承担了"重开"的职责）

**决策**：暂不采用此方案，优先保证操作可预测性和语义清晰

**未来考虑**：

- 如果用户反馈"重做任务"的操作频率很高
- 可以考虑添加专门的"重做"快捷操作（如右键菜单）
- 而非复用在场按钮

---

## 任务编辑面板

### 打开方式

**触发操作**：

- 单击任务卡片

**面板类型**：

- 模态窗口/侧边栏（具体形式待定）

---

### 功能列表

**基本信息**：

- 任务标题（title）
- 任务描述/笔记（notes）

**组织分类**：

- 关联区域（area）- 下拉选择

**子任务**：

- 创建子任务
- 编辑子任务标题
- 删除子任务
- 勾选子任务完成状态

**截止日期**：

- 硬截止日期（hard deadline）- 必须完成
- 软截止日期（soft deadline）- 期望完成
- 无截止日期（默认）

**V1 暂不支持**：

- 优先级设置
- 标签系统
- 依赖关系

---

### 截止日期规则

**类型定义**：

1. **硬截止日期**：
   - 含义：必须在此日期前完成
   - 用途：有明确外部约束的任务（如：提交报告、参加会议）
   - 视觉提示：红色高亮

2. **软截止日期**：
   - 含义：期望在此日期前完成
   - 用途：自我设定的目标日期
   - 视觉提示：橙色提示

3. **无截止日期**：
   - 含义：没有时间限制
   - 用途：长期任务、低优先级任务
   - 视觉提示：无特殊提示

**设置方式**：

- 在任务编辑面板中选择日期
- 可以同时设置硬截止和软截止
- 可以清空截止日期

**V1 功能范围**：

- ✅ 支持设置和显示截止日期
- ❌ 暂不支持逾期提醒
- ❌ 暂不支持按截止日期排序

---

## 核心业务事件

### 【任务完成事件】

触发条件：点击完成按钮（未完成任务）

**执行步骤**：

1. **更新任务状态**
   - 设置 `completed_at` 为当前时间
   - 标记任务为已完成
2. **完成所有子任务**
   - 将所有子任务的 `is_completed` 设置为 true
3. **处理当天日程**
   - 将今日对应的 schedule 标记为完成（`SET outcome = 'COMPLETED_ON_DAY'`）
4. **处理时间片**
   - 截断正在进行的 time_block（结束时间设为当前时间）
   - 删除今日未来的所有 time_block
5. **清理未来数据**
   - 删除所有未来日期的 schedule
   - 删除所有未来日期的 time_block
6. **调整任务排序**
   - 将刚完成的任务移到当前看板所有未完成任务后面

---

### 【创建日程事件】

触发条件：从暂存区拖拽任务到时间看板

**执行步骤**：

1. **创建 schedule**
   - 设置 `scheduled_date` 为目标日期
   - 关联到目标任务

2. **副作用**
   - 任务不再出现在暂存区（因为有了可用排期）

---

### 【回到暂存区事件】

触发条件：从时间看板拖拽任务到暂存区

**执行步骤**：

1. **删除今日和未来日程**
   - 删除今日及未来的所有 schedule
   - 删除今日及未来的所有 time_block

2. **保留过去数据**
   - 过去的 schedule 保留（不删除，outcome 不变）
   - 过去的 time_block 保留（不删除）

3. **已完成任务处理** ✅
   - 允许拖回暂存区
   - 自动重开任务（`SET tasks.completed_at = NULL`）
   - 删除今日及未来的所有 schedule 和 time_block
   - 保留过去的 schedule 和 time_block

---

### 【点击在场按钮事件】

触发条件：点击在场按钮（★）

**执行步骤**：

1. **更新当日 schedule 的 outcome**
   - 如果未点击：`SET outcome = 'PRESENCE_LOGGED'`
   - 如果已点击：`SET outcome = 'PLANNED'`（取消在场）

**注意事项**：

- 仅修改当日 schedule，不影响其他数据
- 可反复点击进行切换
- 不自动创建或修改 time_block

---

### 【重开任务事件】

触发条件：点击完成按钮（已完成任务）

**执行步骤**：

1. **清空完成状态**
   - `SET tasks.completed_at = NULL`

2. **修改当天 schedule 的 outcome**
   - `SET outcome = 'PRESENCE_LOGGED'`（从 COMPLETED_ON_DAY 回退）

**注意事项**：

- 仅修改当天的 schedule 的 outcome
- 不影响 time_block 数据
- 任务重新变为未完成状态
- 保留"在场"状态，允许用户继续调整或再次标记完成

---

### 【归档任务事件】

触发条件：右键菜单 → 归档

**业务语义**：

- 归档 = "暂时放下、不再处理"
- 删除当天及之后的所有日程（未来不再安排）
- 保留过去的日程（历史记录）

**执行步骤**：

1. **删除当天及之后的日程和时间块**
   - 查找所有当天及之后的日程日期
   - 对每个日期：
     - 查找该日期的所有时间块
     - 删除任务到时间块的链接（`task_time_block_links`）
     - 软删除"孤儿"时间块（没有其他任务关联的时间块）
   - 删除所有当天及之后的日程记录（`task_schedules`）

2. **设置归档时间**
   - `SET tasks.archived_at = 当前时间`

3. **保留过去数据**
   - 过去的 schedule 保留（不删除）
   - 过去的 time_block 保留（不删除）
   - 用于历史回顾和数据分析

**副作用**：

- 任务从所有看板消失
- 当天及未来的日程被删除
- 过去的日程被保留（历史记录）
- 可在归档视图查看

**反归档**：

- 右键菜单 → 取消归档
- `SET tasks.archived_at = NULL`
- 任务重新出现在对应看板
- ⚠️ 注意：已删除的未来日程不会自动恢复，需要手动重新安排

**数据示例**：

```
归档前（2025-10-06）：
  10-01: schedule (PRESENCE_LOGGED) ← 保留
  10-02: schedule (COMPLETED_ON_DAY) ← 保留
  10-06: schedule (PLANNED) ← 删除（当天）
  10-10: schedule (PLANNED) ← 删除（未来）
  10-15: schedule (PLANNED) ← 删除（未来）

归档后：
  10-01: schedule (PRESENCE_LOGGED) ✅ 保留
  10-02: schedule (COMPLETED_ON_DAY) ✅ 保留
  tasks.archived_at = 2025-10-06 ✅
```

**心智模型**："这个任务我现在不想做了，但保留过去的工作记录"

---

### 【删除任务事件】

触发条件：右键菜单 → 删除

**执行步骤**：

1. **软删除任务**
   - `SET tasks.is_deleted = true`
   - `SET tasks.deleted_at = 当前时间`

2. **硬删除关联数据**
   - 删除所有 schedule 记录
   - 删除所有 time_block 记录
   - 删除所有 subtask 记录

**副作用**：

- 任务从所有看板消失
- 进入回收站（保留7天）
- 7天后自动永久删除

**回收站**：

- 展示最近7天删除的任务
- 支持恢复（`SET is_deleted = false`, `SET deleted_at = NULL`）
- 恢复时不恢复 schedule 和 time_block（已被硬删除）

---

### 【创建时间块事件】

触发方式：

- 方式1：在日历上直接拖拽创建
- 方式2：从看板拖拽任务到日历

**执行步骤**：

1. **创建 time_block**
   - 设置 `task_id`（关联任务）
   - 设置 `start_time` 和 `end_time`
   - 设置 `scheduled_date`
   - 设置 `is_all_day`（全天槽位 or 时间槽位）

2. **自动创建 schedule（如果不存在）**
   - 为该任务在当天创建 schedule（`outcome = PLANNED`）

**创建规则**：

- ✅ 允许：同一天内的时间范围
- ❌ 禁止：跨天时间块（在日界处自动截断）
- ⚠️ 例外：时区变换导致的"视觉跨天"允许

**修改规则**：

- 拖拽时间块调整时长（拖拽上/下边缘）
- 拖拽时间块移动时间（拖拽中间区域）
- 不允许通过拖拽改变日期（修改日期需删除重建）

**删除规则**：

- 右键菜单 → 删除时间块
- 删除时间块不影响 schedule（保留排期记录）

---

### 全天时间块与定时时间块

**全天时间块**：

- 任务可以关联一个全天时间块（`is_all_day = true`）
- 同时也可以关联当天其他的定时时间块（同一任务多个时间块）
- 在看板上没有显示区别（任务卡片不区分是否有全天时间块）

**转换规则**：

- 全天时间块拖动到时间槽上 → 自动转换为1小时的定时时间块
- 定时时间块无法转换为全天时间块（需删除后重建）

**创建方式**：

- 在日历全天槽位拖拽创建
- 从看板拖拽任务到全天槽位

---

### 子任务管理规则

**创建/编辑/删除**：

- 在任务编辑面板中管理
- 与主任务一起保存

**完成状态联动**：

- 主任务点击完成 → 所有子任务自动设置为完成
- 主任务取消完成 → 子任务状态不变（保持各自状态）

**独立性限制**：

- ❌ 子任务没有独立的排期（schedule）
- ❌ 子任务没有单独的 area
- ❌ 子任务没有独立的截止日期
- ✅ 子任务有独立的完成状态（is_completed）

**显示规则**：

- 在任务卡片上显示为列表
- 可单独勾选完成/取消完成

---

### outcome 状态转换规则

**状态机定义**：

```
[创建排期]
    ↓
PLANNED ←──────────────────┐
    ├→ [点击在场★]          │
    │         ↓             │
    │  PRESENCE_LOGGED      │
    │         ↓             │
    └→ [点击完成✓]          │
              ↓             │
      COMPLETED_ON_DAY      │
              │             │
              └─[取消/重开]──┘
```

**允许的转换**：

| 当前状态         | 操作             | 结果状态         | 触发方式      |
| ---------------- | ---------------- | ---------------- | ------------- |
| PLANNED          | 点击在场         | PRESENCE_LOGGED  | 点击★按钮     |
| PLANNED          | 点击完成         | COMPLETED_ON_DAY | 点击✓按钮     |
| PRESENCE_LOGGED  | 点击在场（取消） | PLANNED          | 再次点击★按钮 |
| PRESENCE_LOGGED  | 点击完成         | COMPLETED_ON_DAY | 点击✓按钮     |
| COMPLETED_ON_DAY | 点击完成（取消） | PRESENCE_LOGGED  | 再次点击✓按钮 |

**禁止的转换**：

- ❌ COMPLETED_ON_DAY → PLANNED（必须先取消到 PRESENCE_LOGGED）

**保留字段**：

- CARRIED_OVER：保留字段，当前版本未使用

**注意事项**：

- outcome 仅影响 schedule 记录，不直接影响 tasks.completed_at
- tasks.completed_at 由【任务完成事件】统一管理
- 一个任务可以多天都是 PRESENCE_LOGGED（分多天完成）

---

## 循环任务管理

### 核心概念

**业务定义**：
- 循环任务 = 基于 RRULE 标准规则，自动在指定日期生成任务实例的功能
- 每个循环规则关联一个模板，根据规则在特定日期自动创建任务

**MVP 方案架构**：

四个核心表：

1. **templates 表**
   - 新增 `category` 字段，包含 `RECURRENCE` 枚举值
   - 循环模板存储任务的基础信息（标题、描述、预估时长等）

2. **tasks 表**
   - 新增 `recurrence_id`：关联的循环规则 ID
   - 新增 `recurrence_original_date`：该实例对应的原始日期

3. **task_recurrences 表**
   - `id`：循环规则 ID
   - `template_id`：关联的模板
   - `rule`：RRULE 标准字符串（如：`FREQ=DAILY;INTERVAL=1`）
   - `time_type`：`FLOATING`（浮动时间）或 `FIXED`（固定时间）
   - `start_date`：生效起始日期（可选）
   - `end_date`：生效结束日期（可选）
   - `is_active`：是否激活

4. **task_recurrence_links 表**
   - 记录循环规则在特定日期已生成的任务实例
   - `(recurrence_id, instance_date)` 有唯一索引，防止重复创建

---

### 循环实例化逻辑

**触发时机**：用户请求某日的任务清单时（`GET /api/views/daily/:date`）

**执行流程**：

1. **查询生效的循环规则**
   - 筛选条件：
     - `is_active = true`
     - `start_date <= 目标日期`（或 start_date 为空）
     - `end_date >= 目标日期`（或 end_date 为空）

2. **对每个循环规则**：
   
   **步骤 2.1**：解析 RRULE，判断是否匹配目标日期
   - 使用 RRULE 标准库解析规则
   - 检查目标日期是否在生成的日期序列中

   **步骤 2.2**：检查链接表
   - 查询 `task_recurrence_links` 是否有该日期的记录

   **步骤 2.3a**：如果链接已存在
   - 获取关联的任务 ID
   - 验证任务是否仍然有效：
     - 任务未删除（`deleted_at IS NULL`）
     - 任务未归档（`archived_at IS NULL`）
     - 任务在该日期有排期（`task_schedules.scheduled_date = 目标日期`）
   - 有效 → 返回该任务
   - 无效 → 不返回（用户已调整，不再属于该日期）

   **步骤 2.3b**：如果链接不存在
   - 从模板创建新任务实例
   - 替换模板变量（如 `{{date}}`）
   - 设置任务的 `recurrence_id` 和 `recurrence_original_date`
   - 创建任务排期（`task_schedules`）
   - 创建链接记录（`task_recurrence_links`）

**关键设计**：

- 实例化在读取时进行（lazy instantiation），不预先生成
- 链接表防止重复创建（数据库唯一索引）
- 用户修改实例不影响规则本身

---

### 【创建循环规则事件】

**触发条件**：用户在任务编辑器中点击"设置为循环"

**执行步骤**：

1. **创建循环模板**
   - 基于当前任务创建模板（`category = 'RECURRENCE'`）
   - 复制任务的标题、描述、预估时长、Area 等

2. **创建循环规则**
   - 设置 RRULE 字符串
   - 设置起止日期
   - 关联到刚创建的模板

3. **链接原任务（可选）**
   - 如果提供了 `source_task_id` 且有 `start_date`
   - 将原任务作为第一个循环实例
   - 创建链接记录，防止在 start_date 重复创建

**前端 UI**：

- 循环配置对话框（RecurrenceConfigDialog）
- 支持配置：频率、间隔、起止日期、星期几等
- 使用 rrule.js 库生成标准 RRULE 字符串

---

### 【修改循环规则事件】

**触发条件**：用户编辑循环规则

**执行步骤**：

1. **验证请求**
   - ❌ 禁止修改 `start_date`（不可变）
   - ✅ 验证 `end_date >= start_date`
   - ✅ 验证 RRULE 中的 `UNTIL` 与 `end_date` 一致

2. **清理不匹配的实例**（如果修改了 `rule`）
   - 查询所有未完成的任务实例
   - 对每个实例，用新规则验证其日期
   - 不匹配的实例：
     - 软删除任务
     - 删除链接记录

3. **清理未来实例**（如果设置了 `end_date`）
   - 查询所有 `recurrence_original_date > end_date` 的未完成实例
   - 软删除这些任务
   - 删除对应的链接记录

**关键设计**：

- 修改规则自动同步已生成的实例
- 保留已完成的实例（不受规则变更影响）
- `start_date` 不可修改（保证数据一致性）

---

### 【停止/继续循环事件】

**触发条件**：用户在任务编辑器中点击"停止重复"或"继续循环"

#### 停止重复

**执行步骤**：

1. **设置结束日期**
   - `SET end_date = recurrence_original_date`
   - 即从当前任务实例的日期开始停止

2. **清理未来实例**
   - 删除所有在 `end_date` 之后的未完成实例
   - 删除对应的链接记录

**心智模型**："从这个日期之后不再生成新任务"

#### 继续循环

**执行步骤**：

1. **清除结束日期**
   - `SET end_date = NULL`

2. **无需恢复实例**
   - 已删除的实例不会自动恢复
   - 未来会按规则重新生成

**心智模型**："清除限制，继续生成新任务"

---

### 【删除循环规则事件】

**触发条件**：用户删除循环规则

**执行步骤**：

1. **清理所有未来的未完成实例**
   - 查询所有今日及之后的未完成实例
   - 清除任务的循环参数：
     ```sql
     SET recurrence_id = NULL
     SET recurrence_original_date = NULL
     ```
   - 软删除这些任务

2. **删除所有链接记录**
   - 删除该循环规则的所有链接（包括已完成实例的链接）

3. **标记规则为不激活**
   - `SET is_active = false`

**关键设计**：

- 删除规则 = 停止循环并清理未完成实例
- 已完成的实例任务保留（但失去循环关联）
- 清除循环参数，任务变为普通任务

---

### 【批量更新循环实例事件】

**触发条件**：用户修改循环规则关联的模板，希望同步到所有实例

**API 端点**：`PATCH /api/recurrences/:id/instances/batch`

**执行步骤**：

1. **查询所有未完成的实例**
   - 可选参数 `update_from_date`：只更新指定日期之后的实例

2. **批量更新任务字段**
   - 支持更新：`title`, `glance_note`, `detail_note`, `estimated_duration`, `area_id`
   - 使用单个 SQL UPDATE 语句批量更新

3. **返回更新数量**

**使用场景**：

- 修改了模板，希望所有未完成的实例同步更新
- 例如：修改标题、调整预估时长、更换 Area

**心智模型**："一次性修改所有未来的循环任务"

---

### 边界情况与验证规则

#### 1. 创建循环规则

**验证规则**：

- ✅ RRULE 字符串格式正确
- ✅ `start_date <= end_date`
- ✅ RRULE 中的 `UNTIL` 与 `end_date` 一致（或省略 UNTIL）
- ✅ 如果提供 `source_task_id`，验证其日期与 `start_date` 匹配

**拒绝场景**：

- ❌ RRULE 解析失败
- ❌ 日期逻辑错误
- ❌ 源任务日期不匹配

#### 2. 修改循环规则

**验证规则**：

- ✅ `start_date` 不可修改（请求中不允许包含此字段）
- ✅ `end_date >= start_date`（基于现有的 start_date）
- ✅ RRULE UNTIL 一致性验证

**自动清理**：

- ✅ 修改 `rule` → 清理不匹配的未完成实例
- ✅ 设置 `end_date` → 清理未来的未完成实例

#### 3. 删除循环模板

**验证规则**：

- ✅ 检查模板是否被激活的循环规则使用
- ❌ 如果有关联的激活循环规则，拒绝删除
- 提示：请先删除或停用循环规则

**心智模型**："循环模板不能删除，除非先停止所有使用它的循环"

#### 4. 并发创建防护

**机制**：

- 数据库唯一索引：`task_recurrence_links(recurrence_id, instance_date)`
- 防止两个请求同时为同一天创建实例

**行为**：

- 第一个请求成功创建
- 第二个请求失败（唯一索引冲突）
- 数据库层面保证一致性

#### 5. 用户手动调整实例

**场景**：用户将循环任务实例改期到其他日期

**行为**：

- 任务的 `task_schedules` 被修改
- 链接记录仍指向原日期
- 下次刷新时，验证失败（任务不在原日期）
- 不返回该实例，不重新创建

**心智模型**："用户调整优先，系统不干预"

#### 6. RRULE UNTIL 与 end_date

**验证要求**：

- 如果 RRULE 包含 `UNTIL` 参数
- 必须与 `end_date` 一致
- 否则拒绝操作

**设计理由**：

- 避免数据不一致（两个结束日期冲突）
- 建议只使用 `end_date`，RRULE 中省略 `UNTIL`

---

### 循环任务的前端展示

#### 任务编辑器

**显示循环状态**：

- 如果任务属于循环实例，显示：
  - 🔄 图标
  - 规则描述（如："每天"、"每周一"）
  - 激活状态标记

**操作按钮**：

- **停止重复**（❌）：设置 `end_date` 为当前实例日期
- **继续循环**（✅）：清除 `end_date`
- **编辑规则**（✏️）：打开编辑对话框
- **删除规则**（🗑️）：删除整个循环规则

#### 循环看板

**位置**：HomeView 右侧边栏

**功能**：

- 列出所有循环规则
- 显示规则的激活状态
- 支持暂停/激活、编辑、删除操作

**UI 组件**：

- `RecurrenceBoard.vue` - 看板容器
- `RecurrenceRuleCard.vue` - 单个规则卡片
- `RecurrenceConfigDialog.vue` - 配置对话框
- `RecurrenceEditDialog.vue` - 编辑对话框

---

### 数据流示例

**示例：创建"每天早上复习"循环任务**

```
1. 用户创建任务"早上复习"（2025-10-10）

2. 用户点击"设置为循环"
   → 打开 RecurrenceConfigDialog
   → 选择：频率=每天，起始日期=2025-10-10

3. 前端生成 RRULE：FREQ=DAILY;INTERVAL=1
   → POST /api/recurrences
   {
     template_id: "xxx",
     rule: "FREQ=DAILY;INTERVAL=1",
     start_date: "2025-10-10",
     source_task_id: "yyy"
   }

4. 后端创建：
   - 循环规则记录
   - 链接记录（2025-10-10 → 原任务）

5. 用户访问 2025-10-11：
   → GET /api/views/daily/2025-10-11
   → 后端检测到循环规则
   → RRULE 匹配 2025-10-11
   → 链接表无记录
   → 创建新任务实例
   → 创建链接记录
   → 返回任务清单（包含新实例）

6. 用户完成 2025-10-11 的任务
   → 任务状态变为已完成
   → 不影响循环规则
   → 2025-10-12 仍会生成新实例

7. 用户在 2025-10-15 点击"停止重复"
   → PATCH /api/recurrences/:id
   { end_date: "2025-10-15" }
   → 后端删除 10-16 及之后的未完成实例
   → 10-16 及之后不再生成新实例
```

---

### 技术实现细节

**RRULE 库**：

- 后端：Rust `rrule` crate
- 前端：JavaScript `rrule` npm 包
- 确保前后端行为一致

**日期格式**：

- 数据库：`YYYY-MM-DD` 字符串
- RRULE DTSTART：`YYYYMMDD` 格式（无连字符）
- 转换在 `recurrence_instantiation_service` 中处理

**事务保证**：

- 所有循环相关操作在事务中完成
- 确保任务、排期、链接的原子性创建/删除

**性能优化**：

- 实例化采用 lazy 模式（读取时生成）
- 不预先生成大量实例
- 链接表作为缓存，避免重复创建

---

## 看板拖拽规则

### 1️⃣ 同一看板内拖动

**行为**：仅调整任务排序，不触发业务逻辑

---

### 2️⃣ 暂存区 → 时间看板

| 目标看板 | 行为 | 业务事件                   |
| -------- | ---- | -------------------------- |
| 过去日期 | 允许 | 创建日程 + 自动标记完成 ✅ |
| 今日     | 允许 | 【创建日程事件】           |
| 未来日期 | 允许 | 【创建日程事件】           |

**心智模型**：排期

**过去日期处理**：

- 创建该日期的 schedule（`outcome = COMPLETED_ON_DAY`）
- 设置 `tasks.completed_at = 过去日期`
- 用途：补录历史完成的任务

---

### 3️⃣ 时间看板 → 暂存区

**心智模型**：取消排期

**行为**：触发【回到暂存区事件】

**已完成任务处理**：

- 允许拖回暂存区
- 自动重开任务（`SET completed_at = NULL`）
- 删除今日及未来的 schedule 和 time_block

---

### 4️⃣ 时间看板 → 时间看板（改期）

**心智模型**：调整排期日期

#### 场景详解

---

##### 场景组 1：过去 → 今日/未来

###### 情况 1.1：已完成任务

**用户意图**：任务虽然过去完成了，但又想重做

**条件判断**：

- 源：过去看板
- 目标：今日或未来看板
- 任务状态：tasks.completed_at 有值
- schedule.outcome：COMPLETED_ON_DAY

**执行逻辑**：

1. 自动重开任务：`SET tasks.completed_at = NULL`
2. 保留源schedule（记录历史完成）
3. 创建目标schedule：`outcome = PLANNED`
4. 提示用户："该任务已完成，拖到新日期将重开任务"

**数据示例**：

```
10-01: schedule.outcome = COMPLETED_ON_DAY（保留）
10-10: schedule.outcome = PLANNED（新建）
tasks.completed_at = NULL（重开）
```

**心智模型**："这个任务我以前做过，现在想再做一次"

---

###### 情况 1.2：未完成任务

**用户意图**：过去计划但没做完，现在想继续做

**条件判断**：

- 源：过去看板
- 目标：今日或未来看板
- 任务状态：tasks.completed_at IS NULL
- schedule.outcome：PLANNED 或 PRESENCE_LOGGED

**执行逻辑**：

1. 保留源schedule（记录过去的计划/工作）
2. 创建目标schedule：`outcome = PLANNED`
3. 任务状态不变（本来就是未完成）

**数据示例**：

```
10-01: schedule.outcome = PRESENCE_LOGGED（保留，记录曾经做过）
10-10: schedule.outcome = PLANNED（新建）
tasks.completed_at = NULL（保持未完成）
```

**心智模型**："这个任务拖了很久，现在重新安排时间做"

---

##### 场景组 2：今日 → 未来

###### 情况 2.1：未完成 + 未点过任何按钮

**用户意图**：今天没时间做，推迟到未来

**条件判断**：

- 源：今日看板
- 目标：未来看板
- 任务状态：未完成
- schedule.outcome：PLANNED（未点过"在场"或"完成"）

**执行逻辑**：

1. **删除**今日schedule（仅仅是计划，没有实际工作）
2. 删除今日所有time_block（如果有）
3. 创建未来schedule：`outcome = PLANNED`

**数据示例**：

```
10-06（今日）: schedule被删除
10-10: schedule.outcome = PLANNED（新建）
```

**心智模型**："今天只是计划做但没做，改期到未来，不留记录"

**关键设计**：轻量改期，不保留无意义的PLANNED记录

---

###### 情况 2.2：未完成 + 点过"在场"

**用户意图**：今天做了一部分但没完成，未来继续做

**条件判断**：

- 源：今日看板
- 目标：未来看板
- 任务状态：未完成
- schedule.outcome：PRESENCE_LOGGED

**执行逻辑**：

1. **保留**今日schedule（记录今天的实际工作）
2. 保留今日所有time_block（记录工作时段）
3. 创建未来schedule：`outcome = PLANNED`

**数据示例**：

```
10-06（今日）: schedule.outcome = PRESENCE_LOGGED（保留）
                + time_block: 14:00-16:00（保留）
10-10: schedule.outcome = PLANNED（新建）
```

**心智模型**："今天确实做了这个任务，虽然没完成，但工作记录要保留"

**关键设计**：区分"仅计划"和"实际工作"，后者必须保留历史

---

###### 情况 2.3：已完成任务

**用户意图**：今天完成了，但又想未来继续做（重做或迭代）

**条件判断**：

- 源：今日看板
- 目标：未来看板
- 任务状态：tasks.completed_at 有值（今天完成）
- schedule.outcome：COMPLETED_ON_DAY

**执行逻辑**：

1. 自动重开任务：`SET tasks.completed_at = NULL`
2. **保留**今日schedule（记录历史完成）
3. 保留今日所有time_block
4. 创建未来schedule：`outcome = PLANNED`
5. 提示用户："该任务已完成，拖到新日期将重开任务"

**数据示例**：

```
10-06（今日）: schedule.outcome = COMPLETED_ON_DAY（保留）
10-10: schedule.outcome = PLANNED（新建）
tasks.completed_at = NULL（重开）
```

**心智模型**："这个任务今天完成了，但我未来还想再做一次"

---

##### 场景组 3：今日 → 过去 **（拒绝操作）** ✅

**用户意图**：补录历史？误操作？

**条件判断**：

- 源：今日看板
- 目标：过去看板
- 任务状态：任意

**决策**：**方案 A - 拒绝操作（静默弹回）**

**执行逻辑**：

- 拖拽被拒绝，任务弹回原位置
- 不弹出提示信息（静默处理）
- 不修改任何数据

**设计理由**：

- 违反时间线逻辑（不能将今天的任务改期到过去）
- 补录应该通过"过去看板的完成按钮"
- 拖拽表示"改期"，拖到过去违反改期语义
- 静默拒绝避免打断用户操作流

**心智模型**：不适用（操作本身违反逻辑）

---

##### 场景组 4：未来 → 今日

###### 情况 4.1：任意状态

**用户意图**：原计划未来做，提前到今天做

**条件判断**：

- 源：未来看板
- 目标：今日看板
- 任务状态：任意（通常是未完成）
- schedule.outcome：PLANNED

**执行逻辑**：

1. **删除**未来schedule（未来的计划作废）
2. 删除未来所有time_block（如果有）
3. 创建今日schedule：`outcome = PLANNED`

**数据示例**：

```
10-10（未来）: schedule被删除
10-06（今日）: schedule.outcome = PLANNED（新建）
```

**心智模型**："原本计划未来做，现在有时间了，提前到今天"

**关键设计**：标准改期，删除源日程，创建新日程

---

##### 场景组 5：未来 → 过去 **（拒绝操作）** ✅

**用户意图**：补录过去？误操作？

**条件判断**：

- 源：未来看板
- 目标：过去看板
- 任务状态：任意

**决策**：**方案 A - 拒绝操作（静默弹回）**

**执行逻辑**：

- 拖拽被拒绝，任务弹回原位置
- 不弹出提示信息（静默处理）
- 不修改任何数据

**设计理由**：

- 违反时间线逻辑（不能将未来的任务改期到过去）
- 与场景组3一致，保持拖拽语义的一致性
- 补录应该通过专门的补录功能
- 静默拒绝避免打断用户操作流

**心智模型**：不适用（操作本身违反逻辑）

---

##### 场景组 6：未来 → 未来

###### 情况 6.1：任意状态

**用户意图**：调整未来的排期日期

**条件判断**：

- 源：未来看板（日期A）
- 目标：未来看板（日期B）
- 任务状态：任意（通常是未完成）
- schedule.outcome：PLANNED

**执行逻辑**：

1. **删除**源日期schedule（计划作废）
2. 删除源日期所有time_block（如果有）
3. 创建目标日期schedule：`outcome = PLANNED`

**数据示例**：

```
10-10: schedule被删除
10-15: schedule.outcome = PLANNED（新建）
```

**心智模型**："远期规划调整，从一个未来日期改到另一个未来日期"

**关键设计**：标准改期，未来日期之间的调整最常见

---

#### 场景汇总表

| 场景组                  | 情况 | 任务状态 | 在场标记 | 操作            | 心智模型           |
| ----------------------- | ---- | -------- | -------- | --------------- | ------------------ |
| **1. 过去 → 今日/未来** | 1.1  | 已完成   | -        | 重开+创建新日程 | 重做已完成的任务   |
|                         | 1.2  | 未完成   | -        | 保留+创建新日程 | 继续拖延的任务     |
| **2. 今日 → 未来**      | 2.1  | 未完成   | ❌ 未点  | 删除+改期       | 轻量推迟（无工作） |
|                         | 2.2  | 未完成   | ✅ 已点  | 保留+改期       | 保留工作记录       |
|                         | 2.3  | 已完成   | -        | 重开+创建新日程 | 重做今日完成的     |
| **3. 今日 → 过去**      | -    | 任意     | -        | **拒绝**        | ❌ 违反逻辑        |
| **4. 未来 → 今日**      | 4.1  | 任意     | -        | 删除+改期       | 提前执行           |
| **5. 未来 → 过去**      | -    | 任意     | -        | **拒绝**        | ❌ 违反逻辑        |
| **6. 未来 → 未来**      | 6.1  | 任意     | -        | 删除+改期       | 远期规划调整       |

---

### 5️⃣ 日历视图交互限制

**允许的操作**：

- ✅ 在日历上直接拖拽创建时间块
- ✅ 从看板拖拽任务到日历（创建时间块）
- ✅ 在日历内拖拽调整时间块的时长
- ✅ 在日历内拖拽移动时间块的时间

**禁止的操作**：

- ❌ 从日历拖拽任务到看板（为了简化逻辑）
- ❌ 从日历拖拽任务到其他日期（需删除后重建）

**设计理由**：

- 日历专注于时间块管理
- 跨视图拖拽保持单向性（看板 → 日历）
- 改期操作统一通过看板完成

---

## 任务排序规则

### 看板内排序

**排序机制**：

- 同一看板内任务**无固定排序算法**
- 支持用户任意拖拽调整顺序
- 顺序通过 view_preferences 表持久化

**重排功能**：

- 提供"重新排序"按钮
- 可按创建时间、优先级、字母顺序等排序
- 未来支持（待实现）

---

### 新任务插入位置

**当前规则**：

- 新创建的任务出现在**所有已完成任务下面**
- 即：位于未完成任务列表的末尾

**未来配置**：

- 通过设置按钮切换插入位置
- 选项1：出现在列表最下面（默认）
- 选项2：出现在列表最上面

---

### 完成任务时的排序变化

**触发时机**：点击完成按钮（✓）完成任务

**排序行为**：

1. 将刚完成的任务移到**所有未完成任务下面**
2. 位于已完成任务区域的顶部
3. 这是一次性自动排序

**后续操作**：

- 用户仍可手动拖拽到其他位置
- 自动排序不锁定位置

**示例**：

```
完成前：
  [ ] 任务A
  [ ] 任务B ← 点击完成
  [ ] 任务C
  [✓] 任务D（已完成）

完成后：
  [ ] 任务A
  [ ] 任务C
  [✓] 任务B ← 自动移到这里
  [✓] 任务D
```

---

### 跨看板拖拽后的排序

**规则**：

- 拖拽到目标看板时，插入到用户拖放的位置
- 通过 view_preferences 记录该位置
- 避免任务总是出现在底部

---

### ⚠️ 未来功能：按 Area 筛选后的排序问题

**场景描述**：

- V1 暂不支持按 area 筛选看板
- 未来支持按 area 筛选时，需要考虑排序问题

**待解决的问题**：

1. **筛选时的排序**：
   - 筛选出特定 area 的任务后，如何排序？
   - 使用原有顺序 or 重新排序？

2. **取消筛选后的恢复**：
   - 取消筛选后，所有看板顺序如何恢复？
   - 是否保留筛选期间的拖拽调整？

**可能的方案**：

- 方案 A：筛选只是视觉过滤，不改变原有排序，取消后自动恢复
- 方案 B：筛选后可以独立调整顺序，取消时询问是否保留
- 方案 C：维护多套排序（全局排序 + 各个 area 的排序）

**决策**：暂不实现，待有用户需求后再决定

---

## Area（项目/上下文）管理

### Area 创建和管理

**管理入口**：

- Area Manager Modal（区域管理弹窗）
- 通过导航链接打开

**Area 属性**：

- 名称（name）
- 颜色（color）- 用于任务卡片标签显示

**基本操作**：

- 创建 area
- 编辑 area（修改名称、颜色）
- 删除 area（需处理关联任务）

---

### 任务与 Area 的关联

**关联方式**：

- 在任务编辑面板中选择 area
- 一个任务只能关联一个 area
- 允许不关联任何 area（area_id 为空）

**取消关联**：

- 在任务编辑面板中清空 area 选择

**显示规则**：

- 任务卡片右下角显示 area 标签（`#区域名称`）
- 使用 area 的颜色显示

---

### Area 筛选功能

**V1 状态**：

- ❌ 暂不支持按 area 筛选看板

**未来计划**：

- ✅ 支持按 area 筛选任务
- 筛选入口：看板顶部筛选器
- 筛选逻辑：仅显示属于选定 area 的任务

---

## 快捷键系统

### V1 状态

**功能范围**：

- ❌ V1 暂不设置任何快捷键
- 所有操作通过鼠标点击完成

---

### 未来规划

**快捷键策略**：

- 所有快捷键默认**不开启**
- 用户需要在设置中手动开启
- 软件**不会自发注册任何系统快捷键**

**设计理由**：

- 尊重用户的快捷键习惯
- 避免与其他软件冲突
- 提供可选的效率提升工具

**可能的快捷键**（待定）：

- 创建新任务
- 快速完成/取消完成
- 快速标记在场
- 打开任务编辑面板
- 切换看板视图

---

## 批量操作

### V1 状态

**功能范围**：

- ❌ V1 暂不支持多选任务
- ❌ V1 暂不支持批量操作

---

### 未来规划

**可能的批量操作**（待定）：

- 批量完成/取消完成
- 批量删除
- 批量归档
- 批量移动到 area
- 批量改期

---

## 待决策事项汇总

### 决策矩阵

| #   | 问题                            | 方案 A               | 方案 B            | 当前决策     | 优先级 |
| --- | ------------------------------- | -------------------- | ----------------- | ------------ | ------ |
| 1   | 暂存区 → 过去日期               | 拒绝操作             | 创建日程+自动完成 | **方案B** ✅ | P1     |
| 2   | 时间看板 → 暂存区（已完成任务） | 拒绝操作             | 允许+自动重开     | **方案B** ✅ | P1     |
| 3   | 今日 → 过去                     | 拒绝操作（静默弹回） | 创建日程+自动完成 | **方案A** ✅ | P2     |
| 4   | 未来 → 过去                     | 拒绝操作（静默弹回） | 创建日程+自动完成 | **方案A** ✅ | P2     |
| 5   | 按 Area 筛选后的排序恢复        | 仅过滤不改序         | 维护独立排序      | 暂不处理     | P3     |
| 6   | 已完成任务显示在场按钮          | 不显示               | 显示+自动重开     | **方案A** ✅ | 已决策 |

**决策说明**：

- **#1 暂存区 → 过去日期**：允许补录历史，自动创建日程并标记完成
- **#2 时间看板 → 暂存区（已完成任务）**：允许拖回，自动重开任务
- **#3, #4 → 过去**：静默拒绝（不弹提示，任务直接弹回原位置）
- **#5 Area 筛选排序**：V1 不支持筛选，暂不处理
- **#6 已完成任务在场按钮**：不显示，保持语义一致

**优先级说明**：

- P0：阻塞开发，立即决策
- P1：影响核心功能，近期决策
- P2：边缘场景，可延后
- P3：未来功能，暂不决策

---

**文档版本**：v5.0
**最后更新**：2025-10-11
**变更说明**：

- v5.0: 新增循环任务管理章节，包含完整的循环任务业务逻辑和技术实现细节
- v4.1: 更新归档任务事件，明确删除当天及未来日程的业务逻辑
- v4.0: 完成6项决策，所有核心业务规则已确定
