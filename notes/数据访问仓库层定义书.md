### **《Cutie后端设计纲要》V1.0**

#### **第四部分：数据访问/仓库层 (Data Access / Repository Layer)**

*   **层级定义书 (CABC for Layer):**
    *   **预期行为简介:** 本层封装了所有与数据库的直接交互。它提供了一系列面向领域对象的、强类型的接口（`Trait`），将SQL查询、数据库事务管理等底层细节完全隐藏。本层是**数据库Schema**和**服务层业务逻辑**之间的唯一桥梁。
    *   **输入输出规范:**
        *   **前置条件:** 所有调用本层方法的输入参数（如ID、实体对象）都应是经过服务层验证的、合法的。本层**不负责**复杂的业务规则验证。
        *   **后置条件:** 所有方法要么成功返回预期的领域模型对象（或`()`），要么返回一个明确的`DbError`（我们可以在`AppError`中定义一个通用的数据库错误类型）。
    *   **不变量:**
        *   本层代码是唯一允许包含SQL语句的地方。
        *   本层方法应尽可能地原子化，即一个方法对应一个或一组紧密相关的数据库查询。
        *   所有需要跨多个仓库操作的业务逻辑，其**事务管理**必须在`服务层`进行，仓库层的方法应能接受一个事务句柄作为参数。

---

#### **1. `TaskRepository` (任务仓库) 接口定义书**

*   **接口签名 (Trait):**
    ```rust
    #[async_trait]
    pub trait TaskRepository: Send + Sync {
        // --- 事务管理 ---
        async fn begin_transaction(&self) -> Result<Transaction, DbError>;
    
        // --- 写操作 ---
        async fn create(&self, tx: &mut Transaction, task: &Task) -> Result<Task, DbError>;
        async fn update(&self, tx: &mut Transaction, task: &Task) -> Result<Task, DbError>;
        async fn set_completed(&self, tx: &mut Transaction, task_id: Uuid, completion_time: DateTime<Utc>) -> Result<Task, DbError>;
        async fn reopen(&self, tx: &mut Transaction, task_id: Uuid) -> Result<Task, DbError>;
    
        // --- 读操作 ---
        async fn find_by_id(&self, task_id: Uuid) -> Result<Option<Task>, DbError>;
        async fn find_many_by_ids(&self, task_ids: &[Uuid]) -> Result<Vec<Task>, DbError>;
        async fn find_unscheduled(&self) -> Result<Vec<Task>, DbError>; // 用于Staging区
    }
    ```
*   **预期行为简介:** 提供对`Task`实体的所有持久化操作。
*   **函数规范 (以`update`为例):**
    *   **预期行为简介:** 根据传入的`Task`对象的`id`，更新数据库中对应记录的所有可变字段。
    *   **输入输出规范:**
        *   **前置条件:** `task.id`必须存在于数据库中。传入的`task`对象必须是完整的。
        *   **后置条件:** 成功后返回更新后的、包含最新`updated_at`的`Task`对象。数据库中的记录与返回对象的状态完全一致。
    *   **边界情况:** 如果`task.id`不存在，应返回`DbError::NotFound`。
    *   **预期副作用:** 修改`tasks`表中的一条记录。`updated_at`字段被更新。

---

#### **2. `TaskScheduleRepository` (任务日程仓库) 接口定义书**

*   **接口签名 (Trait):**
    ```rust
    #[async_trait]
    pub trait TaskScheduleRepository: Send + Sync {
        async fn create(&self, tx: &mut Transaction, schedule: &TaskSchedule) -> Result<TaskSchedule, DbError>;
        async fn update_outcome(&self, tx: &mut Transaction, schedule_id: Uuid, new_outcome: Outcome) -> Result<TaskSchedule, DbError>;
        async fn reschedule(&self, tx: &mut Transaction, schedule_id: Uuid, new_day: DateTime<Utc>) -> Result<TaskSchedule, DbError>;
        async fn delete(&self, tx: &mut Transaction, schedule_id: Uuid) -> Result<(), DbError>;
        async fn delete_all_for_task(&self, tx: &mut Transaction, task_id: Uuid) -> Result<(), DbError>;
        async fn delete_future_for_task(&self, tx: &mut Transaction, task_id: Uuid, since: DateTime<Utc>) -> Result<(), DbError>;
    
        async fn find_by_day(&self, day: DateTime<Utc>) -> Result<Vec<TaskSchedule>, DbError>;
        async fn find_all_for_task(&self, task_id: Uuid) -> Result<Vec<TaskSchedule>, DbError>;
    }
    ```
*   **预期行为简介:** 提供对`Task_Schedule`关联记录的所有持久化操作。
*   **函数规范 (以`delete_future_for_task`为例):**
    *   **预期行为简介:** 删除某个任务在指定日期之后的所有日程安排。
    *   **输入输出规范:**
        *   **前置条件:** `task_id`和`since`时间戳必须有效。
        *   **后置条件:** `task_schedule`表中所有`task_id`匹配且`scheduled_day`大于`since`的记录都将被删除。
    *   **边界情况:** 如果没有未来的日程，操作应直接成功返回，不产生任何影响。
    *   **预期副作用:** 可能会删除`task_schedule`表中的零条或多条记录。

---

#### **3. `OrderingRepository` (排序仓库) 接口定义书**

*   **接口签名 (Trait):**
    ```rust
    #[async_trait]
    pub trait OrderingRepository: Send + Sync {
        async fn upsert(&self, tx: &mut Transaction, ordering: &Ordering) -> Result<Ordering, DbError>;
        async fn delete_for_task_in_context(&self, tx: &mut Transaction, task_id: Uuid, context_type: &ContextType, context_id: &str) -> Result<(), DbError>;
    
        async fn find_for_context(&self, context_type: &ContextType, context_id: &str) -> Result<Vec<Ordering>, DbError>;
    }
    ```
*   **预期行为简介:** 提供对`Ordering`记录的持久化操作，管理所有自定义排序。
*   **函数规范 (以`upsert`为例):**
    *   **预期行为简介:** 根据`context_type`, `context_id`, `task_id`的组合键，创建或更新一条排序记录。
    *   **输入输出规范:**
        *   **前置条件:** 输入的`Ordering`对象必须完整。
        *   **后置条件:** 数据库中存在或更新了对应的排序记录，其`sort_order`值与输入对象一致。
    *   **预期副作用:** 创建或更新`ordering`表中的一条记录。

---

#### **4. `AreaRepository`, `TemplateRepository`, `TimeBlockRepository`等接口定义书**

*   **预期行为简介:** 这些仓库遵循与`TaskRepository`类似的设计模式，为各自的领域实体提供原子化的CRUD及其他必要的数据访问方法。
*   **通用函数规范:**
    *   `create(tx: &mut Transaction, ...)`: 创建一个新实体。
    *   `update(tx: &mut Transaction, ...)`: 更新一个现有实体。
    *   `delete(tx: &mut Transaction, id: Uuid)`: 软删除一个实体（如果该实体支持软删除）。
    *   `find_by_id(id: Uuid)`: 根据ID查找单个实体。
    *   `find_all()`: 查找所有实体（适用于`Area`, `Template`等数量不多的实体）。
    *   所有写操作都必须接受一个事务句柄`tx`作为参数，以便被`服务层`的事务所包裹。

---