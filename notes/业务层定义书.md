### **《Cutie后端设计纲要》V1.0 (修订版)**

#### **第五部分：业务/服务层 (Business / Service Layer)**

**(层级定义书不变)**

---

#### **1. `TaskService` & `ScheduleService` & `OrderingService` 定义书**

*(为了职责更清晰，我们将相关的业务逻辑拆分到不同的服务中，但它们可能在同一个模块下实现)*

##### **事件: `TaskCreatedInContext`**
*   **服务/函数签名:** `TaskService::create_in_context(&self, data: CreateTaskData, context: &CreationContext) -> Result<Task, AppError>`
*   **预期行为简介:** 在指定的上下文中创建一个新任务。
*   **输入输出规范:**
    *   **前置条件:** `data.title`不能为空且长度有效。`context`必须有效（如`project_id`存在）。
    *   **后置条件:** 返回新创建的`Task`对象。数据库中存在新的`Task`记录。根据`context`，对应的`Task_Schedule`或`Ordering`记录被创建。
*   **边界情况:**
    *   `context`无效: **必须**返回`AppError::NotFound`。
    *   `data`验证失败: **必须**返回`AppError::ValidationFailed`。
*   **预期副作用:** 在一个事务内，向`tasks`表插入记录，并可能向`task_schedule`或`ordering`表插入记录。

---

##### **事件: `TaskScheduledToDay` / `TaskRescheduled` / `TaskLinkedToAdditionalDay`**
*(这三个事件由同一个核心服务方法支持，通过不同参数区分)*
*   **服务/函数签名:** `ScheduleService::schedule_task(&self, command: ScheduleCommand) -> Result<TaskSchedule, AppError>`
    *   `ScheduleCommand`枚举: `Move { task_id, source_day, target_day }`, `Link { task_id, target_day }`
*   **预期行为简介:** 将一个任务安排到一个或多个日程中。支持“移动”和“链接”两种模式。
*   **输入输出规范:**
    *   **前置条件:** `task_id`必须指向一个未完成的`Task`。所有日期必须是规范化的零点时间戳。
    *   **后置条件 (Move):** `Task_Schedule`表中原`source_day`的记录被更新为`target_day`。
    *   **后置条件 (Link):** 在`Task_Schedule`表中创建一条新的记录，关联到`target_day`。
*   **边界情况:**
    *   任务已完成: **必须**返回`AppError::Conflict` ("不能为已完成的任务安排日程")。
    *   `Link`到已存在的日程: **必须**幂等地返回成功，不创建重复记录。
    *   `Move`的源日程不存在: **必须**返回`AppError::NotFound`。
*   **预期副作用:** 修改或创建`task_schedule`记录。可能需要更新`ordering`表中的`DAILY_KANBAN`排序。

---

##### **事件: `TaskUnscheduledCompletely`**
*   **服务/函数签名:** `ScheduleService::unschedule_task_completely(&self, task_id: Uuid) -> Result<(), AppError>`
*   **预期行为简介:** 将一个任务从所有日程中移除，使其回归Staging区。
*   **输入输出规范:**
    *   **前置条件:** `task_id`必须存在。
    *   **后置条件:** 成功时不返回内容。`task_schedule`表中所有与该`task_id`相关的记录都被删除。
*   **边界情况:**
    *   任务原本就在Staging区（没有任何日程）: **必须**幂等地返回成功。
*   **预期副作用:** 删除`task_schedule`表中的零条或多条记录。在`ordering`表中为该任务创建`MISC`上下文的排序记录。

---

##### **事件: `TaskGloballyCompleted` / `TaskReopened`**
*   **服务/函数签名 1:** `TaskService::complete_task(&self, task_id: Uuid) -> Result<Task, AppError>`
*   **预期行为简介:** 全局完成一个任务，并清理未来日程。
*   **(CABC已在上一轮详细定义，此处不再重复)**

*   **服务/函数签名 2:** `TaskService::reopen_task(&self, task_id: Uuid) -> Result<Task, AppError>`
*   **预期行为简介:** 将一个已完成的任务重新打开。
*   **输入输出规范:**
    *   **前置条件:** `task_id`必须指向一个已完成的`Task`。
    *   **后置条件:** 返回更新后的`Task`对象，其`completed_at`字段为`NULL`。
*   **边界情况:**
    *   任务本就未完成: **必须**幂等地返回成功。
*   **预期副作用:** 更新`tasks.completed_at`为`NULL`。可能需要根据业务规则重置`task_schedule.outcome`。

---

##### **事件: `TaskDetailsUpdated` / `TaskAreaChanged` / `SubtasksUpdated` / `TaskDueDateChanged`**
*(这些可以合并到一个通用的更新服务中)*
*   **服务/函数签名:** `TaskService::update_task(&self, task_id: Uuid, updates: UpdateTaskData) -> Result<Task, AppError>`
    *   `UpdateTaskData`是一个包含所有可选字段（`title`, `area_id`, `subtasks`, `due_date`等）的结构体。
*   **预期行为简介:** 更新一个任务的一个或多个属性。
*   **输入输出规范:**
    *   **前置条件:** `task_id`必须存在。所有传入的`updates`数据必须通过验证（如`title`不为空）。
    *   **后置条件:** 返回完整更新后的`Task`对象。
*   **边界情况:**
    *   传入空的`updates`对象: **必须**直接返回当前`Task`对象，不执行任何写操作。
*   **预期副作用:** 修改`tasks`表中的一条记录。

---

##### **事件: `PresenceLoggedForDay`**
*   **服务/函数签名:** `ScheduleService::log_presence(&self, task_id: Uuid, day: DateTime<Utc>) -> Result<TaskSchedule, AppError>`
*   **预期行为简介:** 为任务在某天的日程记录“努力已付出”。
*   **输入输出规范:**
    *   **前置条件:** `task_schedule`表中必须存在`task_id`和`day`匹配的记录。该记录的`outcome`不能是`COMPLETED_ON_DAY`。
    *   **后置条件:** 返回更新后的`TaskSchedule`对象，其`outcome`为`PRESENCE_LOGGED`。
*   **边界情况:**
    *   日程不存在: **必须**返回`AppError::NotFound`。
    *   当日已完成: **必须**返回`AppError::Conflict` ("不能为已完成的当日任务记录努力")。
*   **预期副作用:** 修改`task_schedule`表中的一条记录。

---

##### **事件: `DailyTasksReordered` / `MiscTasksReordered`**
*   **服务/函数签名:** `OrderingService::update_order(&self, command: UpdateOrderCommand) -> Result<(), AppError>`
    *   `UpdateOrderCommand`包含`context_type`, `context_id`, `task_id`, `new_sort_order`。
*   **预期行为简介:** 更新一个任务在一个特定上下文中的排序位置。
*   **输入输出规范:**
    *   **前置条件:** `context`和`task_id`必须有效。`new_sort_order`必须是合法的排序字符串。
    *   **后置条件:** 成功时不返回内容。`ordering`表中对应的记录被创建或更新。
*   **预期副作用:** 创建或更新`ordering`表中的一条记录。

---

#### **2. `TimeBlockService` & `TemplateService` & `AreaService` 定义书**

##### **`TimeBlockService`**
*   **`create_time_block`:** 创建一个新的TimeBlock，可能同时链接一个或多个Task。
*   **`update_time_block`:** 更新TimeBlock的起止时间、笔记、Area等。
*   **`delete_time_block`:** 删除一个TimeBlock，并清理所有在`Task_TimeBlock_Link`中的关联。
*   **`link_task_to_block`:** 将一个Task链接到一个已存在的TimeBlock，触发AI推导Area的副作用。
*   **`unlink_task_from_block`:** 从TimeBlock上解除一个Task的链接。

##### **`TemplateService`**
*   **`create_template`, `update_template`, `delete_template`, `get_all_templates`:** 对`Template`实体的完整CRUD。
*   **`create_task_from_template`:** 核心方法。读取一个`Template`，解析变量，然后调用`TaskService::create_in_context`来创建一个具体的`Task`实例。

##### **`AreaService`**
*   **`create_area`, `update_area`, `delete_area`, `get_all_areas`:** 对`Area`实体的完整CRUD。
*   **`delete_area`的边界情况:** 如果一个Area下有关联的Task或Project，**必须**返回`AppError::Conflict`，并提示“无法删除尚在使用的Area”。
